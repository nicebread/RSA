Start-up:#
library("ProjectTemplate")#
setwd("/Users/Felix/Documents/LMU/Research/1 - Konkret in Arbeit/Yorck - RSA")#
#
sourceDir <- function(path, trace = TRUE, ...) {#
   for (nm in list.files(path, pattern = "\\.[RrSsQq]$")) {#
      if(trace) cat(nm,":")           #
      source(file.path(path, nm), ...)#
      if(trace) cat("\n")#
   }#
}#
sourceDir("helpers")#
#
load.project()#
#
#sourceDir("munge")
dat0 <- read.spss("data/Equity_Dyad_Felix.sav", to.data.frame=TRUE)#
dat0 <- read.spss("data/Equity_Dyad_Felix.sav", to.data.frame=TRUE, reencode='CP1252')#
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")                 ## restore original locale#
#
library(memisc)#
dat0 <- as.data.set(spss.portable.file("data/Equity_Dyad_Felix.por"))#
codebook(dat0)#
library(RSA)#
#
dat1 <- as.data.frame(dat0)#
#
dat1$attrak_m <- scale(dat1$attrak_m)#
dat1$attrak_w <- scale(dat1$attrak_w)#
dat1$status_m <- scale(dat1$status_m)#
dat1$status_w <- scale(dat1$status_w)#
dat1$ras_m <- scale(dat1$ras_m)#
dat1$ras_w <- scale(dat1$ras_w)#
#
cache("dat1")
r1 <- RSA(ras_m ~ status_m*status_w, dat1, model="full")
plot(r1)
compare(r1)
options(error=recover)
compare(r1)
r1 <- RSA(ras_m ~ status_m*status_w, dat1)#
plot(r1)#
compare(r1)
x <- r1
str(x$models)
compare(r1)
compare(r1, plot=TRUE)
plot(r1, model="SSD")
r2 <- RSA(ras_w ~ status_m*status_w, dat1, model="full")
x <- r2
is.null(x$models)
sapply(x$models, is.null)
table(sapply(x$models, is.null))["FALSE"]
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
' @title Compare RSA models#
#'#
#' @description#
#' Compare several fit indexes of all models computed from the RSA function#
#'#
#' @details#
#' No details so far.#
#'#
#' @export#
#' @param x An RSA object#
#' @param verbose Should the summary be printed?#
#' @param plot Should the comparison be plotted (using the \code{\link{modeltree}} function)?#
compare <- function(x, verbose=TRUE, plot=FALSE) {#
	## internal helper function: compare models#
	# mL = model list#
	cModels <- function(mL, set, free.max) {#
		aL1 <- anovaList(mL)#
		if (aL1$n.mods > 1 & "full" %in% names(mL)) {#
			n <- nobs(aL1$models[["full"]])#
			a1 <- cbind(aL1$ANOVA, plyr::ldply(aL1$models, function(X) {#
				F <- fitmeasures(X)#
				R <- inspect(X, "r2")#
				names(R) <- "R2"#
				k <- free.max - F["df"]				#
				R2.p <- ifelse(k==0,#
					NA,#
					pf(((n-k-1)*R)/(k*(1-R)), k, n-k-1, lower.tail=FALSE))#
				names(R2.p) <- "R2.p"#
				return(c(F[c("cfi", "tli", "rmsea", "srmr")], R, R2.p))#
#
			}))#
			a1 <- a1[, !grepl(".id", colnames(a1))]#
			a1$k <- free.max - a1$Df#
			a1$R2.adj <- 1 - ((1-a1$R2))*((n-1)/(n-a1$k-1))#
			a1$delta.R2 <- c(NA, a1$R2[1:(nrow(a1)-1)] - a1$R2[2:(nrow(a1))])			#
			a1$model <- rownames(a1)#
			a1$set <- set#
			return(a1)#
		}#
	}#
	if (table(sapply(x$models, is.null))["FALSE"] <= 1) {#
		stop("You need more than one models for comparison!")#
	}#
	with(x$models, {#
	res <- data.frame()#
	if (!is.null(full)) {#
		free.max <- getFreeParameters(full)#
		if (verbose==TRUE) {#
			cat("-------------------------------------------------------------------------\n")	#
			cat("Standard polynomial models:\n")#
			cat("-------------------------------------------------------------------------\n")#
		}#
		res1 <- cModels(list(cubic=cubic, full=full, IA=IA, additive=additive, diff=diff, null=null), set="directed", free.max)#
		if (verbose==TRUE & !is.null(res1)) {#
			cat("Testing directed difference models: Interaction, additive main effects, difference model :\n")#
			cat("-------------------------------------------------------------------------\n")#
			print(round(res1[, 1:16], 3))#
		}#
		res2 <- cModels(list(cubic=cubic, full=full, SRRR=SRRR, SRSD=SRSD, SSD=SSD, sqdiff=sqdiff, null=null), set="flat_sq", free.max)#
		if (verbose==TRUE & !is.null(res2)) {#
			cat("\n\nTesting 'flat ridge' discrepancy models against SRRR and full polynomial model:\n")#
			cat("-------------------------------------------------------------------------\n")#
			print(round(res2[, 1:16], 3))#
		}#
		res3 <- cModels(list(cubic=cubic, full=full, SRRR=SRRR, SRR=SRR, RR=RR, sqdiff=sqdiff, null=null), set="RR", free.max)#
		if (verbose==TRUE & !is.null(res3)) {#
			cat("\n\nTesting 'rising ridge' against full polynomial model:\n")#
			cat("-------------------------------------------------------------------------\n")#
			print(round(res3[, 1:16], 3))#
		}#
		## compute additional comparisons#
		res4 <- cModels(list(full=full, SRR=SRR, SSD=SSD), set="SRR_SSD", free.max)#
		if (verbose==TRUE & !is.null(res4)) {#
			cat("\n\nTesting transition from SRR to SSD model (i.e., removing the mean level effect from SRR):\n")#
			cat("-------------------------------------------------------------------------\n")#
			print(round(res4[, 1:16], 3))#
		}#
		reslist <- list(res1, res2, res3, res4)#
		res <- plyr::rbind.fill(reslist[!sapply(reslist, is.null)])#
	}#
	aL3 <- anovaList(list(absunc=absunc, absdiff=absdiff))#
	if (aL3$n.mods > 1) {#
		if (verbose==TRUE) {#
			cat("\n\n-------------------------------------------------------------------------\n")	#
			cat("Piecewise regression: absolute difference vs. unrestricted difference model\n")#
			cat("-------------------------------------------------------------------------\n")#
		}#
		free.max2 <- getFreeParameters(absunc)#
		a3 <- cbind(aL3$ANOVA, plyr::ldply(aL3$models, function(X) {#
			F <- fitmeasures(X)#
			R <- inspect(X, "r2")#
			names(R) <- "R2"#
			n <- nobs(X)#
			k <- free.max2 - F["df"]#
			R2.p <- pf(((n-k-1)*R)/(k*(1-R)), k, n-k-1, lower.tail=FALSE)#
			names(R2.p) <- "R2.p"#
			return(c(F[c("cfi", "tli", "rmsea", "srmr")], R, R2.p))#
		}))#
		a3 <- a3[, !grepl(".id", colnames(a3))]#
		a3$k <- free.max2 - a3$Df#
		a3$R2.adj <- 1 - ((1-a3$R2))*((nobs(absunc)-1)/(nobs(absunc)-a3$k-1))#
		a3$delta.R2 <- c(NA, a3$R2[1:(nrow(a3)-1)] - a3$R2[2:(nrow(a3))])#
		if (verbose==TRUE) print(round(a3, 3))#
		a3$model <- rownames(a3)#
		a3$set <- "abs"#
		res <- rbind(res, a3)#
	}#
	class(res) <- c("data.frame", "cRSA")#
	if (plot==TRUE) {#
		modeltree(res)#
	}#
	invisible(res)#
	})#
}#
# compare CFI of intercept-only null model#
#
# CFI2 <- function(x, m1="full", m0="null") {#
# 	cfi2 <- 1-(inspect(x$models[[m1]], "fit")['chisq']-inspect(x$models[[m1]], "fit")['df']) / (inspect(x$models[[m0]], "fit")['chisq']-inspect(x$models[[m0]], "fit")['df'])#
# 	names(cfi2) <- "CFI2"#
# 	return(cfi2)#
# }#
# #
# TLI2 <- function(x, m1="full", m0="null") {#
# 	tli2 <- ((inspect(x$models[[m0]], "fit")['chisq'] / inspect(x$models[[m0]], "fit")['df']) - (inspect(x$models[[m1]], "fit")['chisq'] / inspect(x$models[[m1]], "fit")['df'])) / ((inspect(x$models[[m0]], "fit")['chisq'] / inspect(x$models[[m0]], "fit")['df']) - 1)#
# 	names(tli2) <- "TLI2"#
# 	return(tli2)#
# }
r2 <- RSA(ras_w ~ status_m*status_w, dat1)#
plot(r2)#
compare(r2, plot=TRUE)
options(error=NULL)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/files')
sourceDir <- function(path, trace = TRUE, ...) {#
   for (nm in list.files(path, pattern = "\\.[RrSsQq]$")) {#
      if(trace) cat(nm,":")           #
      source(file.path(path, nm), ...)#
      if(trace) cat("\n")#
   }#
}#
#
library(lavaan)#
library(lattice)#
library(grid)#
sourceDir("../package/R")
compare(r2, plot=TRUE)
cor(dat1$ras_m, dat1$ras_w)
compute squared and interaction terms#
dat2 <- RSA:::add.variables(ras_m ~ status_m*status_w, dat1)#
#
model <- "#
# polynomial regression for both outcomes#
ras_m ~ b1m*status_m + b2m*status_w + b3m*status_m2 + b4m*status_m_status_w + b5m*status_w2#
ras_w ~ b1w*status_m + b2w*status_w + b3w*status_m2 + b4w*status_m_status_w + b5w*status_w2#
#
# Residual correlation of DV#
ras_m ~~ ras_w#
#
## Defined parameters#
# Male surface#
a1m := b1m+b2m#
a2m := b3m+b4m+b5m#
a3m := b1m-b2m#
a4m := b3m-b4m+b5m#
x0m := (b2m*b4m - 2*b1m*b5m) / (4*b3m*b5m - b4m^2)#
y0m := (b1m*b4m - 2*b2m*b3m) / (4*b3m*b5m - b4m^2)#
l1m := (b3m + b5m + sqrt((b3m+b5m)^2 - 4*b3m*b5m + b4m^2))/2#
l2m := (b3m + b5m - sqrt((b3m+b5m)^2 - 4*b3m*b5m + b4m^2))/2#
#
# Female surface#
a1w := b1w+b2w#
a2w := b3w+b4w+b5w#
a3w := b1w-b2w#
a4w := b3w-b4w+b5w#
x0w := (b2w*b4w - 2*b1w*b5w) / (4*b3w*b5w - b4w^2)#
y0w := (b1w*b4w - 2*b2w*b3w) / (4*b3w*b5w - b4w^2)#
l1w := (b3w + b5w + sqrt((b3w+b5w)^2 - 4*b3w*b5w + b4w^2))/2#
l2w := (b3w + b5w - sqrt((b3w+b5w)^2 - 4*b3w*b5w + b4w^2))/2#
"#
#
fit1 <- sem(model, data=dat2, fixed.x=TRUE, meanstructure=TRUE)#
summary(fit1)
model.equal <- "#
# polynomial regression for both outcomes#
ras_m ~ b1m*status_m + b2m*status_w + b3m*status_m2 + b4m*status_m_status_w + b5m*status_w2#
ras_w ~ b1w*status_m + b2w*status_w + b3w*status_m2 + b4w*status_m_status_w + b5w*status_w2#
#
# Residual correlation of DV#
ras_m ~~ ras_w#
#
# constraints: set male and female equal#
b1m == b1w#
b2m == b2w#
b3m == b3w#
b4m == b4w#
b5m == b5w#
#
## Defined parameters#
# Joint surface#
a1 := b1m+b2m#
a2 := b3m+b4m+b5m#
a3 := b1m-b2m#
a4 := b3m-b4m+b5m#
x0 := (b2m*b4m - 2*b1m*b5m) / (4*b3m*b5m - b4m^2)#
y0 := (b1m*b4m - 2*b2m*b3m) / (4*b3m*b5m - b4m^2)#
l1 := (b3m + b5m + sqrt((b3m+b5m)^2 - 4*b3m*b5m + b4m^2))/2#
l2 := (b3m + b5m - sqrt((b3m+b5m)^2 - 4*b3m*b5m + b4m^2))/2#
"#
#
fit2 <- sem(model.equal, data=dat2, fixed.x=TRUE, meanstructure=TRUE)#
summary(fit2)
anova(fit1, fit2)
eff <- coef(fit2)#
#
rawpoints <- dat1[, c("status_m", "status_w", "ras_m")]#
limits0 <- abs(c(range(rawpoints[, 1]), range(rawpoints[, 2])))#
limits <- max(limits0)*c(-1, 1)#
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	xlab="Male attractivity", ylab="Female attractivity", zlab="Relationship satisfaction",#
	type="i")
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	xlab="Male attractivity", ylab="Female attractivity", zlab="Relationship satisfaction",#
	type="3")
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	type="3")
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC")#
	type="3")
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3")
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="r"))
rawpoints
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters#
#'#
#' @details#
#' Each plot type has its distinctive advantages. The two-dimensional contour plot gives a clear view of the position of the principal axes and the stationary point. The 3d plot gives a three dimensional impression of the surface, allows overplotting of the original data points (in case an RSA object is provided), and allows the interactive adjustment of regression weights in the \code{\link{demoRSA}} function. The interactive plot allows rotating and exploring a three-dimensional surface with the mouse (nice for demonstration purposes).#
#' If you want to export publication-ready plots, it is recommended to export it with following commands:#
#' \code{p1 <- plot(r1, bw=TRUE)#
#' trellis.device(device="cairo_pdf", filename="RSA_plot.pdf")#
#' print(p1)#
#' dev.off()}#
#'#
#' @aliases plotRSA#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param y3 Y^3 coefficient#
#' @param x3 X^3 coefficient#
#' @param xy2 XY^2 coefficient#
#' @param x2y X^2Y coefficient#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param xlab Label for x axis#
#' @param ylab Label for y axis#
#' @param zlab Label for z axis#
#' @param surface Method for the calculation of the surface z values. "predict" takes the predicted values from the model, "smooth" uses a thin plate smoother (function \code{Tps} from the \code{fields} package) of the raw data#
#' @param lambda lambda parameter for the smoother. Default (NULL) means that it is estimated by the smoother function. Small lambdas around 1 lead to rugged surfaces, big lambdas to very smooth surfaces.#
#' @param rotation Rotation of the 3d surface plot (when type == "3d")#
#' @param label.rotation Rotation of the axis labls (when type == "3d")#
#' @param gridsize Number of grid nodes in each dimension#
#' @param bw Print surface in black and white instead of colors?#
#' @param legend Print color legend for z values?#
#' @param cex Font size factor for axes labels#
#' @param type \code{3d} for 3d surface plot, \code{contour} for 2d contour plot, "interactive" for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient#
#' @param points A list of parameters which define the appearance of the raw scatter points: #
#'	\itemize{#
#'		\item{data: Data frame which contains the coordinates of the raw data points. FIrst column = x, second = y, third = z. This data frame is automatically generated when the plot is based on a fitted RSA-object}#
#'		\item{show = TRUE: Should the original data points be overplotted?}#
#' 		\item{value="raw": Plot the original z value, "predicted": plot the predicted z value}#
#'		\item{jitter = 0: Amount of jitter for the raw data points}#
#'		\item{cex = .5: multiplication factor for point size}#
#' 		\item{out.mark = FALSE: If set to TRUE, outliers according to Bollen & Jackman (1980) are printed as red X symbols. This option works regardless of whether the RSA function has set out.rm to TRUE or FALSE: #
#'			\itemize{#
#'				\item{If out.rm == TRUE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is removed from the model and *not plotted* in plotRSA.}#
#'				\item{If out.rm == TRUE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is removed from the model but plotted and marked in plotRSA.}#
#'				\item{If out.rm == FALSE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is not removed from the model and plotted as a normal point in plotRSA (but not marked as outlier).}#
#'				\item{If out.rm == FALSE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is not removed from the model, but plotted and marked in plotRSA.}#
#'				\item{Example syntax: \code{plotRSA(r1, points=list(show=TRUE, out.mark=TRUE))}}#
#'		}}#
#'	}#
#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param demo Do not change that parameter (internal use only)#
#' @param fit Do not change that parameter (internal use only)#
#' @param param Should the surface parameters a1 to a4 be shown on the plot? In case of a 3d plot a1 to a4 are printed on the upper left side; in case of a contour plot the principal axes are plotted.#
#' @param axes A vector of strings specifying the axes that should be plotted. Can be any combination of c("LOC", "LOIC", "PA1", "PA2"). LOC = line of congruence, LOIC = line of incongruence, PA1 = first principal axis, PA2 = second principal axis#
#' @param project Should the LOC, LOIC, etc. (as defined in parameter \code{axes}) be also plotted as a projection on the bottom of the cube?#
#' @param maxlines Should the maximum lines be plotted? (red: maximum X for a given Y, blue: maximum Y for a given X). Works only in type="3d"#
#' @param link Link function to transform the z axes. Implemented are "identity" (no transformation; default), "probit", and "logit"#
#' @param border Should a thicker border around the surface be plotted? Sometimes this border leaves the surrounding box, which does not look good. In this case the border can be suppressed by setting \code{border=FALSE}.#
#' @param contour A list defining the appearance of contour lines (aka. height lines). show=TRUE: Should the contour lines be plotted on the 3d wireframe plot? (Parameter only relevant for \code{type="3d"}). color = "grey40": Color of the contour lines. highlight = c(): A vector of heights which should be highlighted (i.e., printed in bold). Be careful: the highlighted line is not necessarily exactly at the specified height; instead the nearest height line is selected.#
#' @param hull Plot a bag plot on the surface (This is a bivariate extension of the boxplot. 50% of points are in the inner bag, 50% in the outer region). See Rousseeuw, Ruts, & Tukey (1999).#
#' @param SP.CI Plot the CI of the stationary point (only relevant for \code{type="contour"})#
#' @param distance A vector of three values defining the distance of labels to the axes#
#' @param tck A vector of three values defining the position of labels to the axes (see ?wireframe)#
#' @param pal A palette for shading#
#' @param pal.range Should the color range be scaled to the box (\code{pal.range = "box"}, default), or to the min and max of the surface (\code{pal.range = "surface"})? If set to "box", different surface plots can be compared along their color, as long as the zlim is the same for both.#
#' @param pad Pad controls the margin around the figure (positive numbers: larger margin, negative numbers: smaller margin)#
#'#' @param ... Additional parameters passed to the plotting function (e.g., sub="Title"). A useful title might be the R squared of the plotted model: sub = as.expression(bquote(R^2==.(round(getPar(x, "r2", model="full"), 3))))#
#'#
#' @references#
#' Rousseeuw, P. J., Ruts, I., & Tukey, J. W. (1999). The Bagplot: A Bivariate Boxplot. The American Statistician, 53(4), 382-387. doi:10.1080/00031305.1999.10474494#
#' @seealso \code{\link{demoRSA}}, \code{\link{RSA}}#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' # Default: 3d plot:#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628)#
#' # Contour plot:#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="c")#
#' # Interactive plot (try the mouse!):#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="i")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df, models=c("sqdiff", "full", "IA"))#
#' plot(r1)	# default: model = "full"#
#' plot(r1, model="sqdiff", points=list(show=TRUE, value="predicted"))#
#b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-2, 2); ylim=c(-2, 2); rotation=list(x=-45, y=45, z=35); legend=TRUE; cex=1.2; type="3d"; points=TRUE; demo=FALSE; model="full"; #
#
#b0=-9; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=1; wy=-1;  zlim=NULL; xlim=c(-2, 2); ylim=c(-2, 2); rotation=list(x=-45, y=45, z=35); legend=TRUE; cex=1.2; type="3d"; points=TRUE; demo=FALSE; model="full"; fit=NULL; link="identity"; param=TRUE; gridsize=21;bw=FALSE; pal=NULL; axes=c("LOC", "LOIC", "PA1", "PA2"); distance=c(1, 1, 1); tck=c(1, 1, 1); xlab="X"; ylab="Y"; zlab="Z"; border=TRUE;#
#
## old rotation#
# rotation=list(x=-45, y=45, z=35), label.rotation=list(x=45, y=-25, z=94)#
# distance=c(1, 1, 1), tck=c(1, 1, 1)#
#
plotRSA <- function(x=0, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, x3=0, xy2=0, x2y=0, y3=0, b0=0, type="3d", model="full", #
	xlim=NULL, ylim=NULL, zlim=NULL, xlab=NULL, ylab=NULL, zlab=NULL, #
	surface="predict", lambda=NULL, #
	rotation=list(x=-63, y=32, z=15), label.rotation=list(x=19, y=-40, z=92), #
	gridsize=21, bw=FALSE, legend=TRUE, param=TRUE, #
	axes=c("LOC", "LOIC", "PA1", "PA2"), project=FALSE, maxlines=FALSE,#
	cex=1.2,#
	points = list(data=NULL, show=NA, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE),#
	demo=FALSE, fit=NULL, link="identity", #
	tck=c(1.5, 1.5, 1.5), distance=c(1.3, 1.3, 1.4), border=TRUE, #
	contour = list(show=FALSE, color="grey40", highlight = c()),#
	hull=FALSE, SP.CI=FALSE, #
	pal=NULL, pal.range="box", #
	pad=0, ...) {#
	if (!identical(xlim, ylim)) {warning("Axes dimensions are not equal. The visual diagonal is *not* the line of numerical congruence! Consider choosing identical values for xlim and ylim.")}#
	# define the defaults#
	if (is.null(points$show)) points$show <- TRUE#
	if (is.na(points$show)) {#
		if (is.null(points$data)) {#
			points$show <- FALSE	#
		} else {#
			points$show <- TRUE#
		}#
	}#
	if (is.null(points$value)) points$value <- "raw"#
	if (is.null(points$color)) points$color <- "black"#
	if (is.null(points$jitter)) points$jitter <- 0#
	if (is.null(points$cex)) points$cex <- 0.5#
	if (is.null(points$out.mark)) points$out.mark <- FALSE#
	if (points$show==TRUE & is.null(points$data)) {#
		warning("You must provide a data frame with the coordinates of the raw data points (points = list(show = TRUE, data = ???)). Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (is.null(contour$show)) contour$show <- TRUE#
	if (is.null(contour$color)) contour$color <- "grey40"#
	if (is.null(contour$highlight)) contour$highlight <- c()#
	type <- match.arg(type, c("interactive", "3d", "contour"))#
	surface <- match.arg(surface, c("predict", "smooth"))#
	points[["value"]] <- match.arg(points[["value"]], c("raw", "predicted"))#
#
	if (demo == FALSE) {#
			if (is.null(xlab)) xlab <- "X"#
			if (is.null(ylab)) ylab <- "Y"#
			if (is.null(zlab)) zlab <- "Z"#
			if (is.null(xlim)) {xlim <- c(-2.1, 2.1)}#
			if (is.null(ylim)) {ylim <- c(-2.1, 2.1)}#
	}#
	if (is.null(points$data) & surface == "smooth") {#
		warning("Smoothing only works if data points are provided (points=list(data=???))! Reverting to surface = 'predict'")#
		surface <- "predict"#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy,x3, xy2, x2y, y3)#
	if (!model %in% c("absunc", "absdiff")) {#
		if (!is.null(fit) & model != "cubic" & model != "null") {#
			SP <- RSA.ST(fit, model=model)#
		} else {#
			SP <- RSA.ST(x=x, y=y, xy=xy, x2=x2, y2=y2)#
		}#
		SP.text <- paste0("a", 1:4, ": ", f2(SP$SP$estimate, 2), sig2star(SP$SP$p.value), collapse="    ")#
	} else {#
		SP <- NULL#
		param <- FALSE#
		SP.text <- ""#
	}#
	# build data set#
	grid <- gridsize#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	if (surface == "predict") {#
		new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11, 15:18)]))#
	}#
	if (surface == "smooth") {#
		library(fields)#
		tpsfit <- Tps(points$data[, 1:2], points$data[, 3], scale.type="unscaled", lambda=lambda)#
		new2$z <- predict(tpsfit, new[, c("x", "y")])#
	}#
	# impose link functions#
	logit <- function (x) {log(x/(1-x))}#
	invlogit <- function (x) {1/(1+exp(-x))}#
	link <- match.arg(link, c("identity", "logit", "probit"))#
	if (link == "probit") {#
		z.trans <- 1.7 * new2$z#
		new2$z <- invlogit(z.trans)#
	}#
	if (link == "logit") {#
		new2$z <- invlogit(new2$z)#
	}#
#
	# determine zlim#
	if (!is.null(points$data) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(points$data[, 3], na.rm=TRUE)), max(max(new2$z, na.rm=TRUE), max(points$data[, 3], na.rm=TRUE)))#
	} else {#
		if (is.null(zlim)) zlim <- c(min(new2$z), max(new2$z))#
	}#
	zlim.final <- zlim#
	## Plots#
	if (bw == FALSE) {#
		# RdYlGn palette#
		if (is.null(pal)) {#
			pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
		}#
		gridCol <- ifelse(contour$show == TRUE, "grey60", "grey30")#
	} else {#
		if (is.null(pal)) {#
			pal <- colorRampPalette(c("#FFFFFF", "#AAAAAA", "#030303"), bias=2)(11)#
		}#
		gridCol <- ifelse(contour$show == TRUE, "grey30", "grey30")#
	}#
	if (length(pal) < 2) {legend <- FALSE}#
	# ---------------------------------------------------------------------#
	# Calculate positions of raw points#
	stop();#
	if (points$out.mark == TRUE & is.null(fit)) {#
		warning("Outliers can only be marked if an RSA-object is provided. Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (points$show == TRUE) {#
		if (points$out.mark == FALSE) {#
			data.used <- points$data#
		}#
		if (points$out.mark == TRUE & !is.null(fit)) {#
			data.used <- fit$data.original#
		}#
		if (points$value == "raw") {#
			zpoints <- data.used[, 3]#
		} else if (points$value == "predicted") {#
			N <- colnames(data.used)#
			data.used2 <- add.variables(formula(paste0(N[3], " ~ ", N[1], "*", N[2])), data.used)#
			# calculate predicted values#
			zpoints <- b0 + colSums(C*t(data.used2[, c(#
				N[1],#
				N[2],#
				paste0(N[1], "2"),#
				paste0(N[2], "2"),#
				paste0(N[1], "_", N[2]),#
				"W",#
				paste0("W_", N[1]),#
				paste0("W_", N[2]),#
				paste0(N[1], "3"),#
				paste0(N[1], "_", N[2], "2"),#
				paste0(N[1], "2", "_", N[2]),#
				paste0(N[2], "3")#
			)]))#
		}#
#
		xpoints <- data.used[, 1]#
		ypoints <- data.used[, 2]#
	}#
	# ---------------------------------------------------------------------#
	#  calculate bag plot: bag = outer, loop = inner#
	if (hull==TRUE) {#
		library(aplpack)#
		BAG <- compute.bagplot(xpoints, ypoints)#
		# close the polygon#
		h1 <- rbind(BAG$hull.bag, BAG$hull.bag[1, ])#
		h2 <- rbind(BAG$hull.loop, BAG$hull.loop[1, ])#
#
		# approx: interpolate the points of the bag (in order to get a more smooth fitting line on the z-axis)#
		minDist <- min(diff(xlim)/gridsize, diff(ylim)/gridsize)/2#
#
		h1 <- interpolatePolyon(h1[, 1], h1[, 2], minDist=minDist)	#
		h2 <- interpolatePolyon(h2[, 1], h2[, 2], minDist=minDist)	#
		# calculate predicted values#
		bagpoints <- add.variables(z~x+y, data.frame(x=h1$x, y=h1$y))#
		bagpoints$z <- b0 + colSums(C*t(bagpoints[, c(1:5, 9:11, 15:18)]))#
		bag <- data.frame(X  = bagpoints$x, Y  = bagpoints$y, Z = bagpoints$z)#
		looppoints <- add.variables(z~x+y, data.frame(x=h2$x, y=h2$y))#
		looppoints$z <- b0 + colSums(C*t(looppoints[, c(1:5, 9:11, 15:18)]))#
		loop <- data.frame(X  = looppoints$x, Y  = looppoints$y, Z = looppoints$z)			#
	}#
	## ======================================================================#
	## Interactive plot#
	## ======================================================================#
	if (type == "interactive") {#
		library(rgl)#
		P <- list(x=seq(xlim[1], xlim[2], length.out=grid), y=seq(ylim[1], ylim[2], length.out=grid))#
		DV2 <- matrix(new2$z, nrow=grid, ncol=grid, byrow=FALSE)#
		R <- range(DV2)#
		col2 <- as.character(cut(1:(R[2] - R[1] + 1), breaks=length(pal), labels=pal))#
		open3d()#
		rgl.viewpoint(-30, -90)#
		rgl.light(theta = 0, phi = 90, viewpoint.rel = TRUE, ambient = "#FF0000", diffuse = "#FFFFFF", specular = "#FFFFFF")#
		persp3d(P$x, P$y, DV2, xlab = xlab, ylab = ylab, zlab = zlab, color=col2[DV2 - R[1] + 1])#
#
		if (contour$show == TRUE) {#
		    contours <- contourLines(P, z=DV2)#
		     for (i in 1:length(contours)) {#
				 with(contours[[i]], lines3d(x, y, level, col=contour$color))#
			 }#
		 }#
		if (points$show == TRUE) {#
			if (points$out.mark == FALSE) {#
				points3d(data.frame(xpoints, ypoints, zpoints), col=points$color)#
			}#
			if (points$out.mark == TRUE & !is.null(fit)) {#
				colvec <- rep(points$color, nrow(fit$data.original))#
				colvec[fit$outliers] <- "red"#
				points3d(fit$data.original[, c(fit$IV1, fit$IV2, fit$DV)], col=colvec)#
				text3d(fit$data.original[fit$outliers, c(fit$IV1, fit$IV2, fit$DV)], col="red", texts="X")#
			} else {#
				warning("Please provide an RSA-object to mark outliers.")#
			}#
		}#
		p1 <- NULL	# no plot object is returned	#
	}	#
	## ======================================================================#
	## Wireframe plot#
	## ======================================================================#
	if (type == "3d") {#
			mypanel2 <- function(x, y, z, xlim, ylim, zlim, xlim.scaled, ylim.scaled, zlim.scaled, axes, x.points=NULL, y.points=NULL, z.points=NULL, SPs="", ...) {#
			   # rescale absolute x, y, and z values so that they fit into the box#
			   RESCALE <- function(n) {#
				  X2 <- xlim.scaled[1] + diff(xlim.scaled) * (n$X - xlim[1]) / diff(xlim)#
	              Y2 <- ylim.scaled[1] + diff(ylim.scaled) * (n$Y - ylim[1]) / diff(ylim)#
	              Z2 <- zlim.scaled[1] + diff(zlim.scaled) * (n$Z - zlim[1]) / diff(zlim)#
				  df <- data.frame(X=X2, Y=Y2, Z=Z2)#
				  df <- df[df$X >= min(xlim.scaled) & df$X <= max(xlim.scaled) & df$Y >= min(ylim.scaled) & df$Y <= max(ylim.scaled) &  df$Z >= min(zlim.scaled) & df$Z <= max(zlim.scaled), ]#
				  return(df)#
			   }#
			# ---------------------------------------------------------------------#
			# 1. Projection on bottom of cube#
			  if (project==TRUE) {#
				  for (a in axes) {#
					  #print(paste("Plotting projection of", names(a)))#
					  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1, Z=zlim.final[1] + .01))#
		              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
				  } #
			  }#
			   # ---------------------------------------------------------------------#
			   # 2. Borders, back part#
					if (border==TRUE) {#
						  # Make boundary of grid a bit thicker#
						  box1 <- new2[new2$y == max(new2$y), ]#
						  box2 <- new2[new2$y == min(new2$y), ]#
						  box3 <- new2[new2$x == max(new2$x), ]#
						  box4 <- new2[new2$x == min(new2$x), ]#
						  box <- rbind(data.frame(box1, side=1), data.frame(box2, side=2), data.frame(box3, side=3), data.frame(box4, side=4))#
			              x.box <- xlim.scaled[1] + diff(xlim.scaled) * (box$x - xlim[1]) / diff(xlim)#
			              y.box <- ylim.scaled[1] + diff(ylim.scaled) * (box$y - ylim[1]) / diff(ylim)#
			              z.box <- zlim.scaled[1] + diff(zlim.scaled) * (box$z - zlim[1]) / diff(zlim)#
						  # plot the back lines of the border#
			              panel.3dscatter(x = x.box[box$side==1], y = y.box[box$side==1], z = z.box[box$side==1], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
						  panel.3dscatter(x = x.box[box$side==3], y = y.box[box$side==3], z = z.box[box$side==3], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
					  }#
					  # ---------------------------------------------------------------------#
					  # 3. the surface#
						  panel.3dwire(x = x, y = y, z = z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                           xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
								   col=gridCol,  lwd=0.3, ...)#
					# ---------------------------------------------------------------------#
					# 4. plot of LOC and LOIC, and other axes#
						  for (a in axes) {#
							  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1))#
				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
						  }   #
  					# ---------------------------------------------------------------------#
  					# 4b. plot of maximum lines#
					if (maxlines == TRUE) {#
						# maximum X for a given Y#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[1]/C[5]), p1=-((2*C[3])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="red", lty="dashed", lwd=2, ...)#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[2]/(2*C[4])), p1=-((C[5])/(2*C[4]))))#
							  #a0 <- RESCALE(getIntersect2(p0=-(C[2]/C[5]), p1=-((2*C[4])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="blue", lty="dashed", lwd=2, ...)#
					}#
					# ---------------------------------------------------------------------#
					# 5. Borders, front part	  #
					   if (border==TRUE) {#
 						  # plot the front boundary lines#
 			              panel.3dscatter(x = x.box[box$side==2], y = y.box[box$side==2], z = z.box[box$side==2], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
						  panel.3dscatter(x = x.box[box$side==4], y = y.box[box$side==4], z = z.box[box$side==4], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
					   }#
						  if (param == TRUE) {#
							  grid.text(SPs, .02, .95, just="left")#
						  }  #
						# ---------------------------------------------------------------------#
						# 6a: The bag plot, if requested#
						if (hull==TRUE) {	#
							# bag (= inner bag)#
							if (any(bag$X < xlim[1] | bag$X > xlim[2] | bag$Y < ylim[1] | bag$Y > ylim[2])) {#
								warning("The bag is partly outside the plotting region. Bag is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  bag.rescale <- RESCALE(bag)#
		  		              panel.3dscatter(x = bag.rescale$X, y = bag.rescale$Y, z = bag.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="grey30", lty="dashed", lwd=2, ...)#
							}#
							# loop (= outer bag)#
							if (any(loop$X < xlim[1] | loop$X > xlim[2] | loop$Y < ylim[1] | loop$Y > ylim[2])) {#
								warning("The loop is partly outside the plotting region. Loop is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  loop.rescale <- RESCALE(loop)#
		  		              panel.3dscatter(x = loop.rescale$X, y = loop.rescale$Y, z = loop.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="black", lty="dashed", lwd=2, ...)#
							}#
						}	  	#
						# ---------------------------------------------------------------------#
						# 6b. Raw data points scatter plot	  #
					  		if (points$show == TRUE) {#
	  			              x2 <- xlim.scaled[1] + diff(xlim.scaled) * (x.points - xlim[1]) / diff(xlim)#
							  if (points$jitter > 0) x2 <- x2 + rnorm(length(x2), 0, points$jitter)#
	  			              y2 <- ylim.scaled[1] + diff(ylim.scaled) * (y.points - ylim[1]) / diff(ylim)#
							  if (points$jitter > 0) y2 <- y2 + rnorm(length(y2), 0, points$jitter)#
							  z2 <- zlim.scaled[1] + diff(zlim.scaled) * (z.points - zlim[1]) / diff(zlim)#
	  			              panel.3dscatter(x = x2, y = y2, z = z2, xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=20, col=points$color, cex=points$cex, ...)#
							  # plot outliers#
							  if (points$out.mark==TRUE) {#
	  			              	panel.3dscatter(x = x2[fit$outliers], y = y2[fit$outliers], z = z2[fit$outliers], xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=4, col="red", cex=points$cex, ...)#
							  }#
					  		}	#
					# ---------------------------------------------------------------------#
					# 7. plot contour lines:#
						if (contour$show == TRUE) {#
							cs <- ggplot(new2, aes_string(x="x", y="y", fill="z", z="z")) + stat_contour(bins=ifelse(length(pal)>1, length(pal)+1, 8))#
							cLines <- ggplot_build(cs)#
							C0 <- cLines$data[[1]][, c("x", "y", "level", "group")]#
							colnames(C0) <- c("X", "Y", "Z", "group")#
							for (cL in C0$group) {#
							  C1 <- RESCALE(C0[C0$group==cL, c("X", "Y", "Z")])#
				             panel.3dscatter(x = C1$X, y = C1$Y, z = C1$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                             xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=contour$color, lty="solid", lwd=1, ...)#
							}#
							# highlight specific contour lines?#
							if (length(contour$highlight) > 0) {#
								C2 <- C0[C0$Z %in% f0(unique(C0$Z), contour$highlight), ]#
								for (cL in C2$group) {#
								  C3 <- RESCALE(C2[C2$group==cL, c("X", "Y", "Z")])#
					              panel.3dscatter(x = C3$X, y = C3$Y, z = C3$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
					                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
												  type="l", col.line=contour$color, lty="solid", lwd=2, ...)#
								}#
							}#
						}#
				}#
				# local function: compute the surface line, defined by a line on the X-Y plane (p0 = intercept, p1=slope)#
				getIntersect2 <- function(p0, p1, Z=NULL) {#
					X <- seq(min(xlim), max(xlim), length.out=grid*2)#
					Y <- p0 + p1*X#
					n <- data.frame(X, Y)#
					n2 <- add.variables(z~X+Y, n)#
					n2$Z <- b0 + colSums(c(x, y, x2, y2, xy)*t(n2[, c(1:5)]))#
					if (!is.null(Z)) n2$Z <- Z#
					return(n2[, c("X", "Y", "Z")])#
				}#
				axesList <- list()#
				if ("LOC" %in% axes) {axesList[["LOC"]]  <- list(p0=0, p1=1, lty="solid", col="grey")}#
				if ("LOIC" %in% axes) {axesList[["LOIC"]] <- list(p0=0, p1=-1, lty="dotted", col="grey")}#
				if ("PA1" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA1")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA1"]] <- list(p0=SP2$p10, p1=SP2$p11, lty="solid", col="black")#
						} else {#
							axesList[["PA1"]] <- list(p0=SP$p10, p1=SP$p11, lty="solid", col="black")#
						}					#
				}#
				if ("PA2" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA2")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA2"]] <- list(p0=SP2$p20, p1=SP2$p21, lty="dotted", col="black")#
					} else {#
						axesList[["PA2"]] <- list(p0=SP$p20, p1=SP$p21, lty="dotted", col="black")	#
					}#
				}			#
				# Define color range: Relative to surface min/max, or relative to box (zlim)?#
				if (pal.range == "box") {#
					at <- seq(zlim[1], zlim[2], length.out=length(pal)-1)#
				} else if (pal.range == "surface") {#
					at <- seq(min(new2$z), max(new2$z), length.out=length(pal)-1)#
				}#
			if (points$show == FALSE) {#
				p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation, #
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2, ...)#
				#p1#
			} else {#
				p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation,#
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2,#
					x.points=xpoints, y.points=ypoints, z.points=zpoints, ...)#
			}#
	}  # of type == "3d"#
	## ======================================================================#
	## Contour plot#
	## ======================================================================#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			# Define color range: Relative to surface min/max, or relative to box (zlim)?#
			if (pal.range == "box") {#
				limits <- c(zlim[1], zlim[2])#
			} else if (pal.range == "surface") {#
				limits <- c(min(new2$z), max(new2$z))#
			}#
			p1 <- ggplot(new2, aes_string(x="x", y="y", z="z")) + geom_tile(aes_string(fill="z")) + scale_fill_gradientn(zlab, colours=pal, limits=limits) + theme_bw() + theme(aspect.ratio=1) + xlab(xlab) + ylab(ylab)#
			if (legend==FALSE) {#
				p1 <- p1 + guides(fill=FALSE)#
			}#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# highlight specific contour lines?#
			if (length(contour$highlight) > 0) {#
				cLines <- ggplot_build(p1)#
				C0 <- cLines$data[[2]][, c("x", "y", "level", "group")]#
#
				# Find closest values in contours#
				C1 <- C0[C0$level %in% f0(unique(C0$level), contour$highlight), ]#
				p1 <- p1 + geom_path(data=C1, aes_string(x="x", y="y", group="group", z="level"), size=1.1)#
			}#
			# (in)congruence lines#
			if ("LOC" %in% axes) {#
				p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey")#
			}#
			if ("LOIC" %in% axes) {#
				p1 <- p1 + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			}#
			if (("PA1" %in% axes) & !any(is.na(SP[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=data.frame(SP[c("p10", "p11")]), aes_string(intercept="p10", slope="p11"))#
			}#
			if (("PA2" %in% axes) & !any(is.na(SP[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=data.frame(SP[c("p20", "p21")]), aes_string(intercept="p20", slope="p21"), linetype="dotted")#
			}#
			if (param==TRUE & !any(is.na(SP[c("X0", "Y0")])) & !model %in% c("RR", "sqdiff", "SSD", "SRSD", "SRR", "SRRR")) {#
				p1 <- p1 + annotate("point", x=SP$X0, y=SP$Y0, z=max(new2$z))#
			}#
			if (points$show == TRUE) {#
				if (points$out.mark==FALSE) {#
					p1 <- p1 + annotate("point", x=xpoints, y=ypoints, color=points$color, size=3*points$cex)#
				}#
				if (points$out.mark==TRUE) {#
					colvec <- rep(points$color, nrow(fit$data.original))#
					colvec[fit$outliers] <- "red"#
					shapevec <- rep(19, nrow(fit$data.original))#
					shapevec[fit$outliers] <- 4#
					p1 <- p1 + annotate("point", x=fit$data.original[, fit$IV1], y=fit$data.original[, fit$IV2], color=colvec, size=3*points$cex, shape=shapevec)#
				}#
			}#
			if (hull==TRUE & !is.null(points$data)) {#
				p1 <- p1 + annotate("path", x=bag$X, y=bag$Y, linetype="dashed", color="grey10")#
				p1 <- p1 + annotate("path", x=loop$X, y=loop$Y, linetype="dotted", color="grey10")#
			}#
			# plot CI of SP#
			if (param==TRUE & SP.CI==TRUE & !is.null(fit)) {#
				PAR <- getPar(fit, "coef", model=model)#
				p1 <- p1 + annotate("errorbar", x=SP$X0, y=SP$Y0, ymin=PAR[PAR$label=="Y0", "ci.lower"], ymax=PAR[PAR$label=="Y0", "ci.upper"], z=max(new2$z), width=.3)#
				p1 <- p1 + annotate("errorbarh", x=SP$X0, y=SP$Y0, xmin=PAR[PAR$label=="X0", "ci.lower"], xmax=PAR[PAR$label=="X0", "ci.upper"], z=max(new2$z), height=.3)#
			}#
		}#
	}#
	return(p1)#
}#
#' @S3method plot RSA#
#
# Purpose: Extract the model parameters, xlim, xlab, etc. from the fitted object and give it to the plotRSA function#
plot.RSA <- function(x, ...) {#
	fit <- x#
	extras <- match.call(expand.dots = FALSE)$...#
	if (is.null(extras)) extras <- list()#
	if (is.null(extras$model)) extras$model <- "full"#
	C <- coef(fit$models[[extras$model]])#
	if (fit$models[[extras$model]]@Options$estimator != "DWLS") {#
		extras$b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), 0, C[paste0(fit$DV, "~1")]))#
	} else {			#
		# the threshold is the negative of the intercept ...#
		extras$b0 <- -as.numeric(ifelse(is.na(C[paste0(fit$DV, "|t1")]), 0, C[paste0(fit$DV, "|t1")]))#
	}#
	extras$x <- as.numeric(ifelse(is.na(C["b1"]), 0, C["b1"]))#
	extras$y <- as.numeric(ifelse(is.na(C["b2"]), 0, C["b2"]))#
	extras$x2 <- as.numeric(ifelse(is.na(C["b3"]), 0, C["b3"]))#
	extras$y2 <- as.numeric(ifelse(is.na(C["b5"]), 0, C["b5"]))#
	extras$xy <- as.numeric(ifelse(is.na(C["b4"]), 0, C["b4"]))#
	extras$w <- as.numeric(ifelse(is.na(C["b6"]), 0, C["b6"]))#
	extras$wx <- as.numeric(ifelse(is.na(C["b7"]), 0, C["b7"]))#
	extras$wy <- as.numeric(ifelse(is.na(C["b8"]), 0, C["b8"]))#
	# cubic parameters#
	extras$x3 <- as.numeric(ifelse(is.na(C["b9"]), 0, C["b9"]))#
	extras$xy2 <- as.numeric(ifelse(is.na(C["b10"]), 0, C["b10"]))#
	extras$x2y <- as.numeric(ifelse(is.na(C["b11"]), 0, C["b11"]))#
	extras$y3 <- as.numeric(ifelse(is.na(C["b12"]), 0, C["b12"]))#
#
	if (is.null(extras$xlim)) {#
		extras$xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
		# expand range by 20% at each end#
		extras$xlim[1] <- extras$xlim[1]*ifelse(extras$xlim[1]<0, 1.1, 0.9)#
		extras$xlim[2] <- extras$xlim[2]*ifelse(extras$xlim[2]<0, 0.9, 1.1)#
	}#
	if (is.null(extras$ylim)) {#
		extras$ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
		extras$ylim[1] <- extras$ylim[1]*ifelse(extras$ylim[1]<0, 1.1, 0.9)#
		extras$ylim[2] <- extras$ylim[2]*ifelse(extras$ylim[2]<0, 0.9, 1.1)#
	}#
	# for the correct visual diagonal: same range for X and Y#
	extras$xlim[1] <- extras$ylim[1] <- min(extras$xlim[1], extras$ylim[1])#
	extras$xlim[2] <- extras$ylim[2] <- max(extras$xlim[2], extras$ylim[2])#
	if (is.null(extras$xlab)) extras$xlab <- fit$IV1#
	if (is.null(extras$ylab)) extras$ylab <- fit$IV2#
	if (is.null(extras$zlab)) extras$zlab <- fit$DV#
	if (is.null(extras$points)) {#
		extras$points <- list(show=TRUE, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE)#
	}#
	extras$points$data <- fit$data[, c(fit$IV1, fit$IV2, fit$DV, colnames(fit$data)[which(!colnames(fit$data) %in% c(fit$IV1, fit$IV2, fit$DV))])]#
	extras$fit <- fit#
	do.call(plotRSA, as.list(extras))#
}#
#plot(r1, type="3d", points=list(show=TRUE, cex=2))#
#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, points=list(data=data.frame(x=-1:3, y=-1:3, z=0), show=TRUE))#
#
#plot(r1)#
#plot(r1, points=list(show=TRUE))#
#plotRSA(x=.05, x2=.1, xy=.20, type="3", gridsize=21)#
#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="3d", points=list(show=TRUE), rotation=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, type="3d")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, legend=FALSE, type="3d")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, legend=FALSE, type="c")#
#
#RSA.ST(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102)#
## Minimal example#
#x <- y <- z <- c(1,2,3)#
#df <- data.frame(x, y, z)#
#wireframe(z ~ x*y, df,  scales = list(arrows = FALSE, col = "black", font = 1, tck = c(1, 1, 1), distance =c(1, 1, 1)))#
##
##
#xyplot(z ~ x, df,  scales = list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck), par.settings=list(axis.components=list(left=list(pad1=2))))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="r"))
options(error=recover)
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="r"))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
points$out.mark
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
data.used <- points$data
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
points$value
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
zpoints <- data.used[, 3]
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
xpoints <- data.used[, 1]#
		ypoints <- data.used[, 2]
xpoints
ypoints
z+points
zpoints
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
library(aplpack)#
		BAG <- compute.bagplot(xpoints, ypoints)#
		# close the polygon#
		h1 <- rbind(BAG$hull.bag, BAG$hull.bag[1, ])#
		h2 <- rbind(BAG$hull.loop, BAG$hull.loop[1, ])#
#
		# approx: interpolate the points of the bag (in order to get a more smooth fitting line on the z-axis)#
		minDist <- min(diff(xlim)/gridsize, diff(ylim)/gridsize)/2#
#
		h1 <- interpolatePolyon(h1[, 1], h1[, 2], minDist=minDist)	#
		h2 <- interpolatePolyon(h2[, 1], h2[, 2], minDist=minDist)	#
		# calculate predicted values#
		bagpoints <- add.variables(z~x+y, data.frame(x=h1$x, y=h1$y))#
		bagpoints$z <- b0 + colSums(C*t(bagpoints[, c(1:5, 9:11, 15:18)]))#
		bag <- data.frame(X  = bagpoints$x, Y  = bagpoints$y, Z = bagpoints$z)#
		looppoints <- add.variables(z~x+y, data.frame(x=h2$x, y=h2$y))#
		looppoints$z <- b0 + colSums(C*t(looppoints[, c(1:5, 9:11, 15:18)]))#
		loop <- data.frame(X  = looppoints$x, Y  = looppoints$y, Z = looppoints$z)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
BAG <- compute.bagplot(xpoints, ypoints)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
h1 <- rbind(BAG$hull.bag, BAG$hull.bag[1, ])#
		h2 <- rbind(BAG$hull.loop, BAG$hull.loop[1, ])
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
minDist <- min(diff(xlim)/gridsize, diff(ylim)/gridsize)/2
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
h1 <- interpolatePolyon(h1[, 1], h1[, 2], minDist=minDist)	#
		h2 <- interpolatePolyon(h2[, 1], h2[, 2], minDist=minDist)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
bagpoints <- add.variables(z~x+y, data.frame(x=h1$x, y=h1$y))#
		bagpoints$z <- b0 + colSums(C*t(bagpoints[, c(1:5, 9:11, 15:18)]))#
		bag <- data.frame(X  = bagpoints$x, Y  = bagpoints$y, Z = bagpoints$z)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
looppoints <- add.variables(z~x+y, data.frame(x=h2$x, y=h2$y))#
		looppoints$z <- b0 + colSums(C*t(looppoints[, c(1:5, 9:11, 15:18)]))#
		loop <- data.frame(X  = looppoints$x, Y  = looppoints$y, Z = looppoints$z)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
mypanel2 <- function(x, y, z, xlim, ylim, zlim, xlim.scaled, ylim.scaled, zlim.scaled, axes, x.points=NULL, y.points=NULL, z.points=NULL, SPs="", ...) {#
			   # rescale absolute x, y, and z values so that they fit into the box#
			   RESCALE <- function(n) {#
				  X2 <- xlim.scaled[1] + diff(xlim.scaled) * (n$X - xlim[1]) / diff(xlim)#
	              Y2 <- ylim.scaled[1] + diff(ylim.scaled) * (n$Y - ylim[1]) / diff(ylim)#
	              Z2 <- zlim.scaled[1] + diff(zlim.scaled) * (n$Z - zlim[1]) / diff(zlim)#
				  df <- data.frame(X=X2, Y=Y2, Z=Z2)#
				  df <- df[df$X >= min(xlim.scaled) & df$X <= max(xlim.scaled) & df$Y >= min(ylim.scaled) & df$Y <= max(ylim.scaled) &  df$Z >= min(zlim.scaled) & df$Z <= max(zlim.scaled), ]#
				  return(df)#
			   }#
			# ---------------------------------------------------------------------#
			# 1. Projection on bottom of cube#
			  if (project==TRUE) {#
				  for (a in axes) {#
					  #print(paste("Plotting projection of", names(a)))#
					  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1, Z=zlim.final[1] + .01))#
		              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
				  } #
			  }#
			   # ---------------------------------------------------------------------#
			   # 2. Borders, back part#
					if (border==TRUE) {#
						  # Make boundary of grid a bit thicker#
						  box1 <- new2[new2$y == max(new2$y), ]#
						  box2 <- new2[new2$y == min(new2$y), ]#
						  box3 <- new2[new2$x == max(new2$x), ]#
						  box4 <- new2[new2$x == min(new2$x), ]#
						  box <- rbind(data.frame(box1, side=1), data.frame(box2, side=2), data.frame(box3, side=3), data.frame(box4, side=4))#
			              x.box <- xlim.scaled[1] + diff(xlim.scaled) * (box$x - xlim[1]) / diff(xlim)#
			              y.box <- ylim.scaled[1] + diff(ylim.scaled) * (box$y - ylim[1]) / diff(ylim)#
			              z.box <- zlim.scaled[1] + diff(zlim.scaled) * (box$z - zlim[1]) / diff(zlim)#
						  # plot the back lines of the border#
			              panel.3dscatter(x = x.box[box$side==1], y = y.box[box$side==1], z = z.box[box$side==1], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
						  panel.3dscatter(x = x.box[box$side==3], y = y.box[box$side==3], z = z.box[box$side==3], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
					  }#
					  # ---------------------------------------------------------------------#
					  # 3. the surface#
						  panel.3dwire(x = x, y = y, z = z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                           xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
								   col=gridCol,  lwd=0.3, ...)#
					# ---------------------------------------------------------------------#
					# 4. plot of LOC and LOIC, and other axes#
						  for (a in axes) {#
							  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1))#
				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
						  }   #
  					# ---------------------------------------------------------------------#
  					# 4b. plot of maximum lines#
					if (maxlines == TRUE) {#
						# maximum X for a given Y#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[1]/C[5]), p1=-((2*C[3])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="red", lty="dashed", lwd=2, ...)#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[2]/(2*C[4])), p1=-((C[5])/(2*C[4]))))#
							  #a0 <- RESCALE(getIntersect2(p0=-(C[2]/C[5]), p1=-((2*C[4])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="blue", lty="dashed", lwd=2, ...)#
					}#
					# ---------------------------------------------------------------------#
					# 5. Borders, front part	  #
					   if (border==TRUE) {#
 						  # plot the front boundary lines#
 			              panel.3dscatter(x = x.box[box$side==2], y = y.box[box$side==2], z = z.box[box$side==2], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
						  panel.3dscatter(x = x.box[box$side==4], y = y.box[box$side==4], z = z.box[box$side==4], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
					   }#
						  if (param == TRUE) {#
							  grid.text(SPs, .02, .95, just="left")#
						  }  #
						# ---------------------------------------------------------------------#
						# 6a: The bag plot, if requested#
						if (hull==TRUE) {	#
							# bag (= inner bag)#
							if (any(bag$X < xlim[1] | bag$X > xlim[2] | bag$Y < ylim[1] | bag$Y > ylim[2])) {#
								warning("The bag is partly outside the plotting region. Bag is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  bag.rescale <- RESCALE(bag)#
		  		              panel.3dscatter(x = bag.rescale$X, y = bag.rescale$Y, z = bag.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="grey30", lty="dashed", lwd=2, ...)#
							}#
							# loop (= outer bag)#
							if (any(loop$X < xlim[1] | loop$X > xlim[2] | loop$Y < ylim[1] | loop$Y > ylim[2])) {#
								warning("The loop is partly outside the plotting region. Loop is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  loop.rescale <- RESCALE(loop)#
		  		              panel.3dscatter(x = loop.rescale$X, y = loop.rescale$Y, z = loop.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="black", lty="dashed", lwd=2, ...)#
							}#
						}	  	#
						# ---------------------------------------------------------------------#
						# 6b. Raw data points scatter plot	  #
					  		if (points$show == TRUE) {#
	  			              x2 <- xlim.scaled[1] + diff(xlim.scaled) * (x.points - xlim[1]) / diff(xlim)#
							  if (points$jitter > 0) x2 <- x2 + rnorm(length(x2), 0, points$jitter)#
	  			              y2 <- ylim.scaled[1] + diff(ylim.scaled) * (y.points - ylim[1]) / diff(ylim)#
							  if (points$jitter > 0) y2 <- y2 + rnorm(length(y2), 0, points$jitter)#
							  z2 <- zlim.scaled[1] + diff(zlim.scaled) * (z.points - zlim[1]) / diff(zlim)#
	  			              panel.3dscatter(x = x2, y = y2, z = z2, xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=20, col=points$color, cex=points$cex, ...)#
							  # plot outliers#
							  if (points$out.mark==TRUE) {#
	  			              	panel.3dscatter(x = x2[fit$outliers], y = y2[fit$outliers], z = z2[fit$outliers], xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=4, col="red", cex=points$cex, ...)#
							  }#
					  		}	#
					# ---------------------------------------------------------------------#
					# 7. plot contour lines:#
						if (contour$show == TRUE) {#
							cs <- ggplot(new2, aes_string(x="x", y="y", fill="z", z="z")) + stat_contour(bins=ifelse(length(pal)>1, length(pal)+1, 8))#
							cLines <- ggplot_build(cs)#
							C0 <- cLines$data[[1]][, c("x", "y", "level", "group")]#
							colnames(C0) <- c("X", "Y", "Z", "group")#
							for (cL in C0$group) {#
							  C1 <- RESCALE(C0[C0$group==cL, c("X", "Y", "Z")])#
				             panel.3dscatter(x = C1$X, y = C1$Y, z = C1$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                             xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=contour$color, lty="solid", lwd=1, ...)#
							}#
							# highlight specific contour lines?#
							if (length(contour$highlight) > 0) {#
								C2 <- C0[C0$Z %in% f0(unique(C0$Z), contour$highlight), ]#
								for (cL in C2$group) {#
								  C3 <- RESCALE(C2[C2$group==cL, c("X", "Y", "Z")])#
					              panel.3dscatter(x = C3$X, y = C3$Y, z = C3$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
					                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
												  type="l", col.line=contour$color, lty="solid", lwd=2, ...)#
								}#
							}#
						}#
				}#
				# local function: compute the surface line, defined by a line on the X-Y plane (p0 = intercept, p1=slope)#
				getIntersect2 <- function(p0, p1, Z=NULL) {#
					X <- seq(min(xlim), max(xlim), length.out=grid*2)#
					Y <- p0 + p1*X#
					n <- data.frame(X, Y)#
					n2 <- add.variables(z~X+Y, n)#
					n2$Z <- b0 + colSums(c(x, y, x2, y2, xy)*t(n2[, c(1:5)]))#
					if (!is.null(Z)) n2$Z <- Z#
					return(n2[, c("X", "Y", "Z")])#
				}#
				axesList <- list()#
				if ("LOC" %in% axes) {axesList[["LOC"]]  <- list(p0=0, p1=1, lty="solid", col="grey")}#
				if ("LOIC" %in% axes) {axesList[["LOIC"]] <- list(p0=0, p1=-1, lty="dotted", col="grey")}#
				if ("PA1" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA1")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA1"]] <- list(p0=SP2$p10, p1=SP2$p11, lty="solid", col="black")#
						} else {#
							axesList[["PA1"]] <- list(p0=SP$p10, p1=SP$p11, lty="solid", col="black")#
						}					#
				}#
				if ("PA2" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA2")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA2"]] <- list(p0=SP2$p20, p1=SP2$p21, lty="dotted", col="black")#
					} else {#
						axesList[["PA2"]] <- list(p0=SP$p20, p1=SP$p21, lty="dotted", col="black")	#
					}#
				}			#
				# Define color range: Relative to surface min/max, or relative to box (zlim)?#
				if (pal.range == "box") {#
					at <- seq(zlim[1], zlim[2], length.out=length(pal)-1)#
				} else if (pal.range == "surface") {#
					at <- seq(min(new2$z), max(new2$z), length.out=length(pal)-1)#
				}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
getIntersect2 <- function(p0, p1, Z=NULL) {#
					X <- seq(min(xlim), max(xlim), length.out=grid*2)#
					Y <- p0 + p1*X#
					n <- data.frame(X, Y)#
					n2 <- add.variables(z~X+Y, n)#
					n2$Z <- b0 + colSums(c(x, y, x2, y2, xy)*t(n2[, c(1:5)]))#
					if (!is.null(Z)) n2$Z <- Z#
					return(n2[, c("X", "Y", "Z")])#
				}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
axesList <- list()#
				if ("LOC" %in% axes) {axesList[["LOC"]]  <- list(p0=0, p1=1, lty="solid", col="grey")}#
				if ("LOIC" %in% axes) {axesList[["LOIC"]] <- list(p0=0, p1=-1, lty="dotted", col="grey")}#
				if ("PA1" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA1")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA1"]] <- list(p0=SP2$p10, p1=SP2$p11, lty="solid", col="black")#
						} else {#
							axesList[["PA1"]] <- list(p0=SP$p10, p1=SP$p11, lty="solid", col="black")#
						}					#
				}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
if ("PA2" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA2")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA2"]] <- list(p0=SP2$p20, p1=SP2$p21, lty="dotted", col="black")#
					} else {#
						axesList[["PA2"]] <- list(p0=SP$p20, p1=SP$p21, lty="dotted", col="black")	#
					}#
				}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
if (pal.range == "box") {#
					at <- seq(zlim[1], zlim[2], length.out=length(pal)-1)#
				} else if (pal.range == "surface") {#
					at <- seq(min(new2$z), max(new2$z), length.out=length(pal)-1)#
				}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation,#
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2,#
					x.points=xpoints, y.points=ypoints, z.points=zpoints
)
p1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
as.vector(xpoints)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation,#
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2,#
					x.points=as.vector(xpoints), y.points=as.vector(ypoints), z.points=as.vector(zpoints)
)
p1
options(error=NULL)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters#
#'#
#' @details#
#' Each plot type has its distinctive advantages. The two-dimensional contour plot gives a clear view of the position of the principal axes and the stationary point. The 3d plot gives a three dimensional impression of the surface, allows overplotting of the original data points (in case an RSA object is provided), and allows the interactive adjustment of regression weights in the \code{\link{demoRSA}} function. The interactive plot allows rotating and exploring a three-dimensional surface with the mouse (nice for demonstration purposes).#
#' If you want to export publication-ready plots, it is recommended to export it with following commands:#
#' \code{p1 <- plot(r1, bw=TRUE)#
#' trellis.device(device="cairo_pdf", filename="RSA_plot.pdf")#
#' print(p1)#
#' dev.off()}#
#'#
#' @aliases plotRSA#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param y3 Y^3 coefficient#
#' @param x3 X^3 coefficient#
#' @param xy2 XY^2 coefficient#
#' @param x2y X^2Y coefficient#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param xlab Label for x axis#
#' @param ylab Label for y axis#
#' @param zlab Label for z axis#
#' @param surface Method for the calculation of the surface z values. "predict" takes the predicted values from the model, "smooth" uses a thin plate smoother (function \code{Tps} from the \code{fields} package) of the raw data#
#' @param lambda lambda parameter for the smoother. Default (NULL) means that it is estimated by the smoother function. Small lambdas around 1 lead to rugged surfaces, big lambdas to very smooth surfaces.#
#' @param rotation Rotation of the 3d surface plot (when type == "3d")#
#' @param label.rotation Rotation of the axis labls (when type == "3d")#
#' @param gridsize Number of grid nodes in each dimension#
#' @param bw Print surface in black and white instead of colors?#
#' @param legend Print color legend for z values?#
#' @param cex Font size factor for axes labels#
#' @param type \code{3d} for 3d surface plot, \code{contour} for 2d contour plot, "interactive" for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient#
#' @param points A list of parameters which define the appearance of the raw scatter points: #
#'	\itemize{#
#'		\item{data: Data frame which contains the coordinates of the raw data points. FIrst column = x, second = y, third = z. This data frame is automatically generated when the plot is based on a fitted RSA-object}#
#'		\item{show = TRUE: Should the original data points be overplotted?}#
#' 		\item{value="raw": Plot the original z value, "predicted": plot the predicted z value}#
#'		\item{jitter = 0: Amount of jitter for the raw data points}#
#'		\item{cex = .5: multiplication factor for point size}#
#' 		\item{out.mark = FALSE: If set to TRUE, outliers according to Bollen & Jackman (1980) are printed as red X symbols. This option works regardless of whether the RSA function has set out.rm to TRUE or FALSE: #
#'			\itemize{#
#'				\item{If out.rm == TRUE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is removed from the model and *not plotted* in plotRSA.}#
#'				\item{If out.rm == TRUE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is removed from the model but plotted and marked in plotRSA.}#
#'				\item{If out.rm == FALSE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is not removed from the model and plotted as a normal point in plotRSA (but not marked as outlier).}#
#'				\item{If out.rm == FALSE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is not removed from the model, but plotted and marked in plotRSA.}#
#'				\item{Example syntax: \code{plotRSA(r1, points=list(show=TRUE, out.mark=TRUE))}}#
#'		}}#
#'	}#
#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param demo Do not change that parameter (internal use only)#
#' @param fit Do not change that parameter (internal use only)#
#' @param param Should the surface parameters a1 to a4 be shown on the plot? In case of a 3d plot a1 to a4 are printed on the upper left side; in case of a contour plot the principal axes are plotted.#
#' @param axes A vector of strings specifying the axes that should be plotted. Can be any combination of c("LOC", "LOIC", "PA1", "PA2"). LOC = line of congruence, LOIC = line of incongruence, PA1 = first principal axis, PA2 = second principal axis#
#' @param project Should the LOC, LOIC, etc. (as defined in parameter \code{axes}) be also plotted as a projection on the bottom of the cube?#
#' @param maxlines Should the maximum lines be plotted? (red: maximum X for a given Y, blue: maximum Y for a given X). Works only in type="3d"#
#' @param link Link function to transform the z axes. Implemented are "identity" (no transformation; default), "probit", and "logit"#
#' @param border Should a thicker border around the surface be plotted? Sometimes this border leaves the surrounding box, which does not look good. In this case the border can be suppressed by setting \code{border=FALSE}.#
#' @param contour A list defining the appearance of contour lines (aka. height lines). show=TRUE: Should the contour lines be plotted on the 3d wireframe plot? (Parameter only relevant for \code{type="3d"}). color = "grey40": Color of the contour lines. highlight = c(): A vector of heights which should be highlighted (i.e., printed in bold). Be careful: the highlighted line is not necessarily exactly at the specified height; instead the nearest height line is selected.#
#' @param hull Plot a bag plot on the surface (This is a bivariate extension of the boxplot. 50% of points are in the inner bag, 50% in the outer region). See Rousseeuw, Ruts, & Tukey (1999).#
#' @param SP.CI Plot the CI of the stationary point (only relevant for \code{type="contour"})#
#' @param distance A vector of three values defining the distance of labels to the axes#
#' @param tck A vector of three values defining the position of labels to the axes (see ?wireframe)#
#' @param pal A palette for shading#
#' @param pal.range Should the color range be scaled to the box (\code{pal.range = "box"}, default), or to the min and max of the surface (\code{pal.range = "surface"})? If set to "box", different surface plots can be compared along their color, as long as the zlim is the same for both.#
#' @param pad Pad controls the margin around the figure (positive numbers: larger margin, negative numbers: smaller margin)#
#'#' @param ... Additional parameters passed to the plotting function (e.g., sub="Title"). A useful title might be the R squared of the plotted model: sub = as.expression(bquote(R^2==.(round(getPar(x, "r2", model="full"), 3))))#
#'#
#' @references#
#' Rousseeuw, P. J., Ruts, I., & Tukey, J. W. (1999). The Bagplot: A Bivariate Boxplot. The American Statistician, 53(4), 382-387. doi:10.1080/00031305.1999.10474494#
#' @seealso \code{\link{demoRSA}}, \code{\link{RSA}}#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' # Default: 3d plot:#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628)#
#' # Contour plot:#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="c")#
#' # Interactive plot (try the mouse!):#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="i")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df, models=c("sqdiff", "full", "IA"))#
#' plot(r1)	# default: model = "full"#
#' plot(r1, model="sqdiff", points=list(show=TRUE, value="predicted"))#
#b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-2, 2); ylim=c(-2, 2); rotation=list(x=-45, y=45, z=35); legend=TRUE; cex=1.2; type="3d"; points=TRUE; demo=FALSE; model="full"; #
#
#b0=-9; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=1; wy=-1;  zlim=NULL; xlim=c(-2, 2); ylim=c(-2, 2); rotation=list(x=-45, y=45, z=35); legend=TRUE; cex=1.2; type="3d"; points=TRUE; demo=FALSE; model="full"; fit=NULL; link="identity"; param=TRUE; gridsize=21;bw=FALSE; pal=NULL; axes=c("LOC", "LOIC", "PA1", "PA2"); distance=c(1, 1, 1); tck=c(1, 1, 1); xlab="X"; ylab="Y"; zlab="Z"; border=TRUE;#
#
## old rotation#
# rotation=list(x=-45, y=45, z=35), label.rotation=list(x=45, y=-25, z=94)#
# distance=c(1, 1, 1), tck=c(1, 1, 1)#
#
plotRSA <- function(x=0, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, x3=0, xy2=0, x2y=0, y3=0, b0=0, type="3d", model="full", #
	xlim=NULL, ylim=NULL, zlim=NULL, xlab=NULL, ylab=NULL, zlab=NULL, #
	surface="predict", lambda=NULL, #
	rotation=list(x=-63, y=32, z=15), label.rotation=list(x=19, y=-40, z=92), #
	gridsize=21, bw=FALSE, legend=TRUE, param=TRUE, #
	axes=c("LOC", "LOIC", "PA1", "PA2"), project=FALSE, maxlines=FALSE,#
	cex=1.2,#
	points = list(data=NULL, show=NA, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE),#
	demo=FALSE, fit=NULL, link="identity", #
	tck=c(1.5, 1.5, 1.5), distance=c(1.3, 1.3, 1.4), border=TRUE, #
	contour = list(show=FALSE, color="grey40", highlight = c()),#
	hull=FALSE, SP.CI=FALSE, #
	pal=NULL, pal.range="box", #
	pad=0, ...) {#
	if (!identical(xlim, ylim)) {warning("Axes dimensions are not equal. The visual diagonal is *not* the line of numerical congruence! Consider choosing identical values for xlim and ylim.")}#
	# define the defaults#
	if (is.null(points$show)) points$show <- TRUE#
	if (is.na(points$show)) {#
		if (is.null(points$data)) {#
			points$show <- FALSE	#
		} else {#
			points$show <- TRUE#
		}#
	}#
	if (is.null(points$value)) points$value <- "raw"#
	if (is.null(points$color)) points$color <- "black"#
	if (is.null(points$jitter)) points$jitter <- 0#
	if (is.null(points$cex)) points$cex <- 0.5#
	if (is.null(points$out.mark)) points$out.mark <- FALSE#
	if (points$show==TRUE & is.null(points$data)) {#
		warning("You must provide a data frame with the coordinates of the raw data points (points = list(show = TRUE, data = ???)). Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (is.null(contour$show)) contour$show <- TRUE#
	if (is.null(contour$color)) contour$color <- "grey40"#
	if (is.null(contour$highlight)) contour$highlight <- c()#
	type <- match.arg(type, c("interactive", "3d", "contour"))#
	surface <- match.arg(surface, c("predict", "smooth"))#
	points[["value"]] <- match.arg(points[["value"]], c("raw", "predicted"))#
#
	if (demo == FALSE) {#
			if (is.null(xlab)) xlab <- "X"#
			if (is.null(ylab)) ylab <- "Y"#
			if (is.null(zlab)) zlab <- "Z"#
			if (is.null(xlim)) {xlim <- c(-2.1, 2.1)}#
			if (is.null(ylim)) {ylim <- c(-2.1, 2.1)}#
	}#
	if (is.null(points$data) & surface == "smooth") {#
		warning("Smoothing only works if data points are provided (points=list(data=???))! Reverting to surface = 'predict'")#
		surface <- "predict"#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy,x3, xy2, x2y, y3)#
	if (!model %in% c("absunc", "absdiff")) {#
		if (!is.null(fit) & model != "cubic" & model != "null") {#
			SP <- RSA.ST(fit, model=model)#
		} else {#
			SP <- RSA.ST(x=x, y=y, xy=xy, x2=x2, y2=y2)#
		}#
		SP.text <- paste0("a", 1:4, ": ", f2(SP$SP$estimate, 2), sig2star(SP$SP$p.value), collapse="    ")#
	} else {#
		SP <- NULL#
		param <- FALSE#
		SP.text <- ""#
	}#
	# build data set#
	grid <- gridsize#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	if (surface == "predict") {#
		new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11, 15:18)]))#
	}#
	if (surface == "smooth") {#
		library(fields)#
		tpsfit <- Tps(points$data[, 1:2], points$data[, 3], scale.type="unscaled", lambda=lambda)#
		new2$z <- predict(tpsfit, new[, c("x", "y")])#
	}#
	# impose link functions#
	logit <- function (x) {log(x/(1-x))}#
	invlogit <- function (x) {1/(1+exp(-x))}#
	link <- match.arg(link, c("identity", "logit", "probit"))#
	if (link == "probit") {#
		z.trans <- 1.7 * new2$z#
		new2$z <- invlogit(z.trans)#
	}#
	if (link == "logit") {#
		new2$z <- invlogit(new2$z)#
	}#
#
	# determine zlim#
	if (!is.null(points$data) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(points$data[, 3], na.rm=TRUE)), max(max(new2$z, na.rm=TRUE), max(points$data[, 3], na.rm=TRUE)))#
	} else {#
		if (is.null(zlim)) zlim <- c(min(new2$z), max(new2$z))#
	}#
	zlim.final <- zlim#
	## Plots#
	if (bw == FALSE) {#
		# RdYlGn palette#
		if (is.null(pal)) {#
			pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
		}#
		gridCol <- ifelse(contour$show == TRUE, "grey60", "grey30")#
	} else {#
		if (is.null(pal)) {#
			pal <- colorRampPalette(c("#FFFFFF", "#AAAAAA", "#030303"), bias=2)(11)#
		}#
		gridCol <- ifelse(contour$show == TRUE, "grey30", "grey30")#
	}#
	if (length(pal) < 2) {legend <- FALSE}#
	# ---------------------------------------------------------------------#
	# Calculate positions of raw points#
	stop();#
	if (points$out.mark == TRUE & is.null(fit)) {#
		warning("Outliers can only be marked if an RSA-object is provided. Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (points$show == TRUE) {#
		if (points$out.mark == FALSE) {#
			data.used <- points$data#
		}#
		if (points$out.mark == TRUE & !is.null(fit)) {#
			data.used <- fit$data.original#
		}#
		if (points$value == "raw") {#
			zpoints <- as.vector(data.used[, 3])#
		} else if (points$value == "predicted") {#
			N <- colnames(data.used)#
			data.used2 <- add.variables(formula(paste0(N[3], " ~ ", N[1], "*", N[2])), data.used)#
			# calculate predicted values#
			zpoints <- b0 + colSums(C*t(data.used2[, c(#
				N[1],#
				N[2],#
				paste0(N[1], "2"),#
				paste0(N[2], "2"),#
				paste0(N[1], "_", N[2]),#
				"W",#
				paste0("W_", N[1]),#
				paste0("W_", N[2]),#
				paste0(N[1], "3"),#
				paste0(N[1], "_", N[2], "2"),#
				paste0(N[1], "2", "_", N[2]),#
				paste0(N[2], "3")#
			)]))#
			zpoints <- as.vector(zpoints)#
		}#
#
		xpoints <- as.vector(data.used[, 1])#
		ypoints <- as.vector(data.used[, 2])#
	}#
	# ---------------------------------------------------------------------#
	#  calculate bag plot: bag = outer, loop = inner#
	if (hull==TRUE) {#
		library(aplpack)#
		BAG <- compute.bagplot(xpoints, ypoints)#
		# close the polygon#
		h1 <- rbind(BAG$hull.bag, BAG$hull.bag[1, ])#
		h2 <- rbind(BAG$hull.loop, BAG$hull.loop[1, ])#
#
		# approx: interpolate the points of the bag (in order to get a more smooth fitting line on the z-axis)#
		minDist <- min(diff(xlim)/gridsize, diff(ylim)/gridsize)/2#
#
		h1 <- interpolatePolyon(h1[, 1], h1[, 2], minDist=minDist)	#
		h2 <- interpolatePolyon(h2[, 1], h2[, 2], minDist=minDist)	#
		# calculate predicted values#
		bagpoints <- add.variables(z~x+y, data.frame(x=h1$x, y=h1$y))#
		bagpoints$z <- b0 + colSums(C*t(bagpoints[, c(1:5, 9:11, 15:18)]))#
		bag <- data.frame(X  = bagpoints$x, Y  = bagpoints$y, Z = bagpoints$z)#
		looppoints <- add.variables(z~x+y, data.frame(x=h2$x, y=h2$y))#
		looppoints$z <- b0 + colSums(C*t(looppoints[, c(1:5, 9:11, 15:18)]))#
		loop <- data.frame(X  = looppoints$x, Y  = looppoints$y, Z = looppoints$z)			#
	}#
	## ======================================================================#
	## Interactive plot#
	## ======================================================================#
	if (type == "interactive") {#
		library(rgl)#
		P <- list(x=seq(xlim[1], xlim[2], length.out=grid), y=seq(ylim[1], ylim[2], length.out=grid))#
		DV2 <- matrix(new2$z, nrow=grid, ncol=grid, byrow=FALSE)#
		R <- range(DV2)#
		col2 <- as.character(cut(1:(R[2] - R[1] + 1), breaks=length(pal), labels=pal))#
		open3d()#
		rgl.viewpoint(-30, -90)#
		rgl.light(theta = 0, phi = 90, viewpoint.rel = TRUE, ambient = "#FF0000", diffuse = "#FFFFFF", specular = "#FFFFFF")#
		persp3d(P$x, P$y, DV2, xlab = xlab, ylab = ylab, zlab = zlab, color=col2[DV2 - R[1] + 1])#
#
		if (contour$show == TRUE) {#
		    contours <- contourLines(P, z=DV2)#
		     for (i in 1:length(contours)) {#
				 with(contours[[i]], lines3d(x, y, level, col=contour$color))#
			 }#
		 }#
		if (points$show == TRUE) {#
			if (points$out.mark == FALSE) {#
				points3d(data.frame(xpoints, ypoints, zpoints), col=points$color)#
			}#
			if (points$out.mark == TRUE & !is.null(fit)) {#
				colvec <- rep(points$color, nrow(fit$data.original))#
				colvec[fit$outliers] <- "red"#
				points3d(fit$data.original[, c(fit$IV1, fit$IV2, fit$DV)], col=colvec)#
				text3d(fit$data.original[fit$outliers, c(fit$IV1, fit$IV2, fit$DV)], col="red", texts="X")#
			} else {#
				warning("Please provide an RSA-object to mark outliers.")#
			}#
		}#
		p1 <- NULL	# no plot object is returned	#
	}	#
	## ======================================================================#
	## Wireframe plot#
	## ======================================================================#
	if (type == "3d") {#
			mypanel2 <- function(x, y, z, xlim, ylim, zlim, xlim.scaled, ylim.scaled, zlim.scaled, axes, x.points=NULL, y.points=NULL, z.points=NULL, SPs="", ...) {#
			   # rescale absolute x, y, and z values so that they fit into the box#
			   RESCALE <- function(n) {#
				  X2 <- xlim.scaled[1] + diff(xlim.scaled) * (n$X - xlim[1]) / diff(xlim)#
	              Y2 <- ylim.scaled[1] + diff(ylim.scaled) * (n$Y - ylim[1]) / diff(ylim)#
	              Z2 <- zlim.scaled[1] + diff(zlim.scaled) * (n$Z - zlim[1]) / diff(zlim)#
				  df <- data.frame(X=X2, Y=Y2, Z=Z2)#
				  df <- df[df$X >= min(xlim.scaled) & df$X <= max(xlim.scaled) & df$Y >= min(ylim.scaled) & df$Y <= max(ylim.scaled) &  df$Z >= min(zlim.scaled) & df$Z <= max(zlim.scaled), ]#
				  return(df)#
			   }#
			# ---------------------------------------------------------------------#
			# 1. Projection on bottom of cube#
			  if (project==TRUE) {#
				  for (a in axes) {#
					  #print(paste("Plotting projection of", names(a)))#
					  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1, Z=zlim.final[1] + .01))#
		              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
				  } #
			  }#
			   # ---------------------------------------------------------------------#
			   # 2. Borders, back part#
					if (border==TRUE) {#
						  # Make boundary of grid a bit thicker#
						  box1 <- new2[new2$y == max(new2$y), ]#
						  box2 <- new2[new2$y == min(new2$y), ]#
						  box3 <- new2[new2$x == max(new2$x), ]#
						  box4 <- new2[new2$x == min(new2$x), ]#
						  box <- rbind(data.frame(box1, side=1), data.frame(box2, side=2), data.frame(box3, side=3), data.frame(box4, side=4))#
			              x.box <- xlim.scaled[1] + diff(xlim.scaled) * (box$x - xlim[1]) / diff(xlim)#
			              y.box <- ylim.scaled[1] + diff(ylim.scaled) * (box$y - ylim[1]) / diff(ylim)#
			              z.box <- zlim.scaled[1] + diff(zlim.scaled) * (box$z - zlim[1]) / diff(zlim)#
						  # plot the back lines of the border#
			              panel.3dscatter(x = x.box[box$side==1], y = y.box[box$side==1], z = z.box[box$side==1], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
						  panel.3dscatter(x = x.box[box$side==3], y = y.box[box$side==3], z = z.box[box$side==3], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
					  }#
					  # ---------------------------------------------------------------------#
					  # 3. the surface#
						  panel.3dwire(x = x, y = y, z = z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                           xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
								   col=gridCol,  lwd=0.3, ...)#
					# ---------------------------------------------------------------------#
					# 4. plot of LOC and LOIC, and other axes#
						  for (a in axes) {#
							  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1))#
				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
						  }   #
  					# ---------------------------------------------------------------------#
  					# 4b. plot of maximum lines#
					if (maxlines == TRUE) {#
						# maximum X for a given Y#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[1]/C[5]), p1=-((2*C[3])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="red", lty="dashed", lwd=2, ...)#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[2]/(2*C[4])), p1=-((C[5])/(2*C[4]))))#
							  #a0 <- RESCALE(getIntersect2(p0=-(C[2]/C[5]), p1=-((2*C[4])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="blue", lty="dashed", lwd=2, ...)#
					}#
					# ---------------------------------------------------------------------#
					# 5. Borders, front part	  #
					   if (border==TRUE) {#
 						  # plot the front boundary lines#
 			              panel.3dscatter(x = x.box[box$side==2], y = y.box[box$side==2], z = z.box[box$side==2], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
						  panel.3dscatter(x = x.box[box$side==4], y = y.box[box$side==4], z = z.box[box$side==4], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
					   }#
						  if (param == TRUE) {#
							  grid.text(SPs, .02, .95, just="left")#
						  }  #
						# ---------------------------------------------------------------------#
						# 6a: The bag plot, if requested#
						if (hull==TRUE) {	#
							# bag (= inner bag)#
							if (any(bag$X < xlim[1] | bag$X > xlim[2] | bag$Y < ylim[1] | bag$Y > ylim[2])) {#
								warning("The bag is partly outside the plotting region. Bag is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  bag.rescale <- RESCALE(bag)#
		  		              panel.3dscatter(x = bag.rescale$X, y = bag.rescale$Y, z = bag.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="grey30", lty="dashed", lwd=2, ...)#
							}#
							# loop (= outer bag)#
							if (any(loop$X < xlim[1] | loop$X > xlim[2] | loop$Y < ylim[1] | loop$Y > ylim[2])) {#
								warning("The loop is partly outside the plotting region. Loop is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  loop.rescale <- RESCALE(loop)#
		  		              panel.3dscatter(x = loop.rescale$X, y = loop.rescale$Y, z = loop.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="black", lty="dashed", lwd=2, ...)#
							}#
						}	  	#
						# ---------------------------------------------------------------------#
						# 6b. Raw data points scatter plot	  #
					  		if (points$show == TRUE) {#
	  			              x2 <- xlim.scaled[1] + diff(xlim.scaled) * (x.points - xlim[1]) / diff(xlim)#
							  if (points$jitter > 0) x2 <- x2 + rnorm(length(x2), 0, points$jitter)#
	  			              y2 <- ylim.scaled[1] + diff(ylim.scaled) * (y.points - ylim[1]) / diff(ylim)#
							  if (points$jitter > 0) y2 <- y2 + rnorm(length(y2), 0, points$jitter)#
							  z2 <- zlim.scaled[1] + diff(zlim.scaled) * (z.points - zlim[1]) / diff(zlim)#
	  			              panel.3dscatter(x = x2, y = y2, z = z2, xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=20, col=points$color, cex=points$cex, ...)#
							  # plot outliers#
							  if (points$out.mark==TRUE) {#
	  			              	panel.3dscatter(x = x2[fit$outliers], y = y2[fit$outliers], z = z2[fit$outliers], xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=4, col="red", cex=points$cex, ...)#
							  }#
					  		}	#
					# ---------------------------------------------------------------------#
					# 7. plot contour lines:#
						if (contour$show == TRUE) {#
							cs <- ggplot(new2, aes_string(x="x", y="y", fill="z", z="z")) + stat_contour(bins=ifelse(length(pal)>1, length(pal)+1, 8))#
							cLines <- ggplot_build(cs)#
							C0 <- cLines$data[[1]][, c("x", "y", "level", "group")]#
							colnames(C0) <- c("X", "Y", "Z", "group")#
							for (cL in C0$group) {#
							  C1 <- RESCALE(C0[C0$group==cL, c("X", "Y", "Z")])#
				             panel.3dscatter(x = C1$X, y = C1$Y, z = C1$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                             xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=contour$color, lty="solid", lwd=1, ...)#
							}#
							# highlight specific contour lines?#
							if (length(contour$highlight) > 0) {#
								C2 <- C0[C0$Z %in% f0(unique(C0$Z), contour$highlight), ]#
								for (cL in C2$group) {#
								  C3 <- RESCALE(C2[C2$group==cL, c("X", "Y", "Z")])#
					              panel.3dscatter(x = C3$X, y = C3$Y, z = C3$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
					                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
												  type="l", col.line=contour$color, lty="solid", lwd=2, ...)#
								}#
							}#
						}#
				}#
				# local function: compute the surface line, defined by a line on the X-Y plane (p0 = intercept, p1=slope)#
				getIntersect2 <- function(p0, p1, Z=NULL) {#
					X <- seq(min(xlim), max(xlim), length.out=grid*2)#
					Y <- p0 + p1*X#
					n <- data.frame(X, Y)#
					n2 <- add.variables(z~X+Y, n)#
					n2$Z <- b0 + colSums(c(x, y, x2, y2, xy)*t(n2[, c(1:5)]))#
					if (!is.null(Z)) n2$Z <- Z#
					return(n2[, c("X", "Y", "Z")])#
				}#
				axesList <- list()#
				if ("LOC" %in% axes) {axesList[["LOC"]]  <- list(p0=0, p1=1, lty="solid", col="grey")}#
				if ("LOIC" %in% axes) {axesList[["LOIC"]] <- list(p0=0, p1=-1, lty="dotted", col="grey")}#
				if ("PA1" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA1")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA1"]] <- list(p0=SP2$p10, p1=SP2$p11, lty="solid", col="black")#
						} else {#
							axesList[["PA1"]] <- list(p0=SP$p10, p1=SP$p11, lty="solid", col="black")#
						}					#
				}#
				if ("PA2" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA2")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA2"]] <- list(p0=SP2$p20, p1=SP2$p21, lty="dotted", col="black")#
					} else {#
						axesList[["PA2"]] <- list(p0=SP$p20, p1=SP$p21, lty="dotted", col="black")	#
					}#
				}			#
				# Define color range: Relative to surface min/max, or relative to box (zlim)?#
				if (pal.range == "box") {#
					at <- seq(zlim[1], zlim[2], length.out=length(pal)-1)#
				} else if (pal.range == "surface") {#
					at <- seq(min(new2$z), max(new2$z), length.out=length(pal)-1)#
				}#
			if (points$show == FALSE) {#
				p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation, #
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2, ...)#
				#p1#
			} else {#
				p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation,#
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2,#
					x.points=xpoints, y.points=ypoints, z.points=zpoints, ...)#
			}#
	}  # of type == "3d"#
	## ======================================================================#
	## Contour plot#
	## ======================================================================#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			# Define color range: Relative to surface min/max, or relative to box (zlim)?#
			if (pal.range == "box") {#
				limits <- c(zlim[1], zlim[2])#
			} else if (pal.range == "surface") {#
				limits <- c(min(new2$z), max(new2$z))#
			}#
			p1 <- ggplot(new2, aes_string(x="x", y="y", z="z")) + geom_tile(aes_string(fill="z")) + scale_fill_gradientn(zlab, colours=pal, limits=limits) + theme_bw() + theme(aspect.ratio=1) + xlab(xlab) + ylab(ylab)#
			if (legend==FALSE) {#
				p1 <- p1 + guides(fill=FALSE)#
			}#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# highlight specific contour lines?#
			if (length(contour$highlight) > 0) {#
				cLines <- ggplot_build(p1)#
				C0 <- cLines$data[[2]][, c("x", "y", "level", "group")]#
#
				# Find closest values in contours#
				C1 <- C0[C0$level %in% f0(unique(C0$level), contour$highlight), ]#
				p1 <- p1 + geom_path(data=C1, aes_string(x="x", y="y", group="group", z="level"), size=1.1)#
			}#
			# (in)congruence lines#
			if ("LOC" %in% axes) {#
				p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey")#
			}#
			if ("LOIC" %in% axes) {#
				p1 <- p1 + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			}#
			if (("PA1" %in% axes) & !any(is.na(SP[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=data.frame(SP[c("p10", "p11")]), aes_string(intercept="p10", slope="p11"))#
			}#
			if (("PA2" %in% axes) & !any(is.na(SP[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=data.frame(SP[c("p20", "p21")]), aes_string(intercept="p20", slope="p21"), linetype="dotted")#
			}#
			if (param==TRUE & !any(is.na(SP[c("X0", "Y0")])) & !model %in% c("RR", "sqdiff", "SSD", "SRSD", "SRR", "SRRR")) {#
				p1 <- p1 + annotate("point", x=SP$X0, y=SP$Y0, z=max(new2$z))#
			}#
			if (points$show == TRUE) {#
				if (points$out.mark==FALSE) {#
					p1 <- p1 + annotate("point", x=xpoints, y=ypoints, color=points$color, size=3*points$cex)#
				}#
				if (points$out.mark==TRUE) {#
					colvec <- rep(points$color, nrow(fit$data.original))#
					colvec[fit$outliers] <- "red"#
					shapevec <- rep(19, nrow(fit$data.original))#
					shapevec[fit$outliers] <- 4#
					p1 <- p1 + annotate("point", x=fit$data.original[, fit$IV1], y=fit$data.original[, fit$IV2], color=colvec, size=3*points$cex, shape=shapevec)#
				}#
			}#
			if (hull==TRUE & !is.null(points$data)) {#
				p1 <- p1 + annotate("path", x=bag$X, y=bag$Y, linetype="dashed", color="grey10")#
				p1 <- p1 + annotate("path", x=loop$X, y=loop$Y, linetype="dotted", color="grey10")#
			}#
			# plot CI of SP#
			if (param==TRUE & SP.CI==TRUE & !is.null(fit)) {#
				PAR <- getPar(fit, "coef", model=model)#
				p1 <- p1 + annotate("errorbar", x=SP$X0, y=SP$Y0, ymin=PAR[PAR$label=="Y0", "ci.lower"], ymax=PAR[PAR$label=="Y0", "ci.upper"], z=max(new2$z), width=.3)#
				p1 <- p1 + annotate("errorbarh", x=SP$X0, y=SP$Y0, xmin=PAR[PAR$label=="X0", "ci.lower"], xmax=PAR[PAR$label=="X0", "ci.upper"], z=max(new2$z), height=.3)#
			}#
		}#
	}#
	return(p1)#
}#
#' @S3method plot RSA#
#
# Purpose: Extract the model parameters, xlim, xlab, etc. from the fitted object and give it to the plotRSA function#
plot.RSA <- function(x, ...) {#
	fit <- x#
	extras <- match.call(expand.dots = FALSE)$...#
	if (is.null(extras)) extras <- list()#
	if (is.null(extras$model)) extras$model <- "full"#
	C <- coef(fit$models[[extras$model]])#
	if (fit$models[[extras$model]]@Options$estimator != "DWLS") {#
		extras$b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), 0, C[paste0(fit$DV, "~1")]))#
	} else {			#
		# the threshold is the negative of the intercept ...#
		extras$b0 <- -as.numeric(ifelse(is.na(C[paste0(fit$DV, "|t1")]), 0, C[paste0(fit$DV, "|t1")]))#
	}#
	extras$x <- as.numeric(ifelse(is.na(C["b1"]), 0, C["b1"]))#
	extras$y <- as.numeric(ifelse(is.na(C["b2"]), 0, C["b2"]))#
	extras$x2 <- as.numeric(ifelse(is.na(C["b3"]), 0, C["b3"]))#
	extras$y2 <- as.numeric(ifelse(is.na(C["b5"]), 0, C["b5"]))#
	extras$xy <- as.numeric(ifelse(is.na(C["b4"]), 0, C["b4"]))#
	extras$w <- as.numeric(ifelse(is.na(C["b6"]), 0, C["b6"]))#
	extras$wx <- as.numeric(ifelse(is.na(C["b7"]), 0, C["b7"]))#
	extras$wy <- as.numeric(ifelse(is.na(C["b8"]), 0, C["b8"]))#
	# cubic parameters#
	extras$x3 <- as.numeric(ifelse(is.na(C["b9"]), 0, C["b9"]))#
	extras$xy2 <- as.numeric(ifelse(is.na(C["b10"]), 0, C["b10"]))#
	extras$x2y <- as.numeric(ifelse(is.na(C["b11"]), 0, C["b11"]))#
	extras$y3 <- as.numeric(ifelse(is.na(C["b12"]), 0, C["b12"]))#
#
	if (is.null(extras$xlim)) {#
		extras$xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
		# expand range by 20% at each end#
		extras$xlim[1] <- extras$xlim[1]*ifelse(extras$xlim[1]<0, 1.1, 0.9)#
		extras$xlim[2] <- extras$xlim[2]*ifelse(extras$xlim[2]<0, 0.9, 1.1)#
	}#
	if (is.null(extras$ylim)) {#
		extras$ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
		extras$ylim[1] <- extras$ylim[1]*ifelse(extras$ylim[1]<0, 1.1, 0.9)#
		extras$ylim[2] <- extras$ylim[2]*ifelse(extras$ylim[2]<0, 0.9, 1.1)#
	}#
	# for the correct visual diagonal: same range for X and Y#
	extras$xlim[1] <- extras$ylim[1] <- min(extras$xlim[1], extras$ylim[1])#
	extras$xlim[2] <- extras$ylim[2] <- max(extras$xlim[2], extras$ylim[2])#
	if (is.null(extras$xlab)) extras$xlab <- fit$IV1#
	if (is.null(extras$ylab)) extras$ylab <- fit$IV2#
	if (is.null(extras$zlab)) extras$zlab <- fit$DV#
	if (is.null(extras$points)) {#
		extras$points <- list(show=TRUE, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE)#
	}#
	extras$points$data <- fit$data[, c(fit$IV1, fit$IV2, fit$DV, colnames(fit$data)[which(!colnames(fit$data) %in% c(fit$IV1, fit$IV2, fit$DV))])]#
	extras$fit <- fit#
	do.call(plotRSA, as.list(extras))#
}#
#plot(r1, type="3d", points=list(show=TRUE, cex=2))#
#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, points=list(data=data.frame(x=-1:3, y=-1:3, z=0), show=TRUE))#
#
#plot(r1)#
#plot(r1, points=list(show=TRUE))#
#plotRSA(x=.05, x2=.1, xy=.20, type="3", gridsize=21)#
#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="3d", points=list(show=TRUE), rotation=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, type="3d")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, legend=FALSE, type="3d")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, legend=FALSE, type="c")#
#
#RSA.ST(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102)#
## Minimal example#
#x <- y <- z <- c(1,2,3)#
#df <- data.frame(x, y, z)#
#wireframe(z ~ x*y, df,  scales = list(arrows = FALSE, col = "black", font = 1, tck = c(1, 1, 1), distance =c(1, 1, 1)))#
##
##
#xyplot(z ~ x, df,  scales = list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck), par.settings=list(axis.components=list(left=list(pad1=2))))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="r"))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters#
#'#
#' @details#
#' Each plot type has its distinctive advantages. The two-dimensional contour plot gives a clear view of the position of the principal axes and the stationary point. The 3d plot gives a three dimensional impression of the surface, allows overplotting of the original data points (in case an RSA object is provided), and allows the interactive adjustment of regression weights in the \code{\link{demoRSA}} function. The interactive plot allows rotating and exploring a three-dimensional surface with the mouse (nice for demonstration purposes).#
#' If you want to export publication-ready plots, it is recommended to export it with following commands:#
#' \code{p1 <- plot(r1, bw=TRUE)#
#' trellis.device(device="cairo_pdf", filename="RSA_plot.pdf")#
#' print(p1)#
#' dev.off()}#
#'#
#' @aliases plotRSA#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param y3 Y^3 coefficient#
#' @param x3 X^3 coefficient#
#' @param xy2 XY^2 coefficient#
#' @param x2y X^2Y coefficient#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param xlab Label for x axis#
#' @param ylab Label for y axis#
#' @param zlab Label for z axis#
#' @param surface Method for the calculation of the surface z values. "predict" takes the predicted values from the model, "smooth" uses a thin plate smoother (function \code{Tps} from the \code{fields} package) of the raw data#
#' @param lambda lambda parameter for the smoother. Default (NULL) means that it is estimated by the smoother function. Small lambdas around 1 lead to rugged surfaces, big lambdas to very smooth surfaces.#
#' @param rotation Rotation of the 3d surface plot (when type == "3d")#
#' @param label.rotation Rotation of the axis labls (when type == "3d")#
#' @param gridsize Number of grid nodes in each dimension#
#' @param bw Print surface in black and white instead of colors?#
#' @param legend Print color legend for z values?#
#' @param cex Font size factor for axes labels#
#' @param type \code{3d} for 3d surface plot, \code{contour} for 2d contour plot, "interactive" for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient#
#' @param points A list of parameters which define the appearance of the raw scatter points: #
#'	\itemize{#
#'		\item{data: Data frame which contains the coordinates of the raw data points. FIrst column = x, second = y, third = z. This data frame is automatically generated when the plot is based on a fitted RSA-object}#
#'		\item{show = TRUE: Should the original data points be overplotted?}#
#' 		\item{value="raw": Plot the original z value, "predicted": plot the predicted z value}#
#'		\item{jitter = 0: Amount of jitter for the raw data points}#
#'		\item{cex = .5: multiplication factor for point size}#
#' 		\item{out.mark = FALSE: If set to TRUE, outliers according to Bollen & Jackman (1980) are printed as red X symbols. This option works regardless of whether the RSA function has set out.rm to TRUE or FALSE: #
#'			\itemize{#
#'				\item{If out.rm == TRUE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is removed from the model and *not plotted* in plotRSA.}#
#'				\item{If out.rm == TRUE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is removed from the model but plotted and marked in plotRSA.}#
#'				\item{If out.rm == FALSE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is not removed from the model and plotted as a normal point in plotRSA (but not marked as outlier).}#
#'				\item{If out.rm == FALSE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is not removed from the model, but plotted and marked in plotRSA.}#
#'				\item{Example syntax: \code{plotRSA(r1, points=list(show=TRUE, out.mark=TRUE))}}#
#'		}}#
#'	}#
#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param demo Do not change that parameter (internal use only)#
#' @param fit Do not change that parameter (internal use only)#
#' @param param Should the surface parameters a1 to a4 be shown on the plot? In case of a 3d plot a1 to a4 are printed on the upper left side; in case of a contour plot the principal axes are plotted.#
#' @param axes A vector of strings specifying the axes that should be plotted. Can be any combination of c("LOC", "LOIC", "PA1", "PA2"). LOC = line of congruence, LOIC = line of incongruence, PA1 = first principal axis, PA2 = second principal axis#
#' @param project Should the LOC, LOIC, etc. (as defined in parameter \code{axes}) be also plotted as a projection on the bottom of the cube?#
#' @param maxlines Should the maximum lines be plotted? (red: maximum X for a given Y, blue: maximum Y for a given X). Works only in type="3d"#
#' @param link Link function to transform the z axes. Implemented are "identity" (no transformation; default), "probit", and "logit"#
#' @param border Should a thicker border around the surface be plotted? Sometimes this border leaves the surrounding box, which does not look good. In this case the border can be suppressed by setting \code{border=FALSE}.#
#' @param contour A list defining the appearance of contour lines (aka. height lines). show=TRUE: Should the contour lines be plotted on the 3d wireframe plot? (Parameter only relevant for \code{type="3d"}). color = "grey40": Color of the contour lines. highlight = c(): A vector of heights which should be highlighted (i.e., printed in bold). Be careful: the highlighted line is not necessarily exactly at the specified height; instead the nearest height line is selected.#
#' @param hull Plot a bag plot on the surface (This is a bivariate extension of the boxplot. 50% of points are in the inner bag, 50% in the outer region). See Rousseeuw, Ruts, & Tukey (1999).#
#' @param SP.CI Plot the CI of the stationary point (only relevant for \code{type="contour"})#
#' @param distance A vector of three values defining the distance of labels to the axes#
#' @param tck A vector of three values defining the position of labels to the axes (see ?wireframe)#
#' @param pal A palette for shading#
#' @param pal.range Should the color range be scaled to the box (\code{pal.range = "box"}, default), or to the min and max of the surface (\code{pal.range = "surface"})? If set to "box", different surface plots can be compared along their color, as long as the zlim is the same for both.#
#' @param pad Pad controls the margin around the figure (positive numbers: larger margin, negative numbers: smaller margin)#
#'#' @param ... Additional parameters passed to the plotting function (e.g., sub="Title"). A useful title might be the R squared of the plotted model: sub = as.expression(bquote(R^2==.(round(getPar(x, "r2", model="full"), 3))))#
#'#
#' @references#
#' Rousseeuw, P. J., Ruts, I., & Tukey, J. W. (1999). The Bagplot: A Bivariate Boxplot. The American Statistician, 53(4), 382-387. doi:10.1080/00031305.1999.10474494#
#' @seealso \code{\link{demoRSA}}, \code{\link{RSA}}#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' # Default: 3d plot:#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628)#
#' # Contour plot:#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="c")#
#' # Interactive plot (try the mouse!):#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="i")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df, models=c("sqdiff", "full", "IA"))#
#' plot(r1)	# default: model = "full"#
#' plot(r1, model="sqdiff", points=list(show=TRUE, value="predicted"))#
#b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-2, 2); ylim=c(-2, 2); rotation=list(x=-45, y=45, z=35); legend=TRUE; cex=1.2; type="3d"; points=TRUE; demo=FALSE; model="full"; #
#
#b0=-9; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=1; wy=-1;  zlim=NULL; xlim=c(-2, 2); ylim=c(-2, 2); rotation=list(x=-45, y=45, z=35); legend=TRUE; cex=1.2; type="3d"; points=TRUE; demo=FALSE; model="full"; fit=NULL; link="identity"; param=TRUE; gridsize=21;bw=FALSE; pal=NULL; axes=c("LOC", "LOIC", "PA1", "PA2"); distance=c(1, 1, 1); tck=c(1, 1, 1); xlab="X"; ylab="Y"; zlab="Z"; border=TRUE;#
#
## old rotation#
# rotation=list(x=-45, y=45, z=35), label.rotation=list(x=45, y=-25, z=94)#
# distance=c(1, 1, 1), tck=c(1, 1, 1)#
#
plotRSA <- function(x=0, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, x3=0, xy2=0, x2y=0, y3=0, b0=0, type="3d", model="full", #
	xlim=NULL, ylim=NULL, zlim=NULL, xlab=NULL, ylab=NULL, zlab=NULL, #
	surface="predict", lambda=NULL, #
	rotation=list(x=-63, y=32, z=15), label.rotation=list(x=19, y=-40, z=92), #
	gridsize=21, bw=FALSE, legend=TRUE, param=TRUE, #
	axes=c("LOC", "LOIC", "PA1", "PA2"), project=FALSE, maxlines=FALSE,#
	cex=1.2,#
	points = list(data=NULL, show=NA, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE),#
	demo=FALSE, fit=NULL, link="identity", #
	tck=c(1.5, 1.5, 1.5), distance=c(1.3, 1.3, 1.4), border=TRUE, #
	contour = list(show=FALSE, color="grey40", highlight = c()),#
	hull=FALSE, SP.CI=FALSE, #
	pal=NULL, pal.range="box", #
	pad=0, ...) {#
	if (!identical(xlim, ylim)) {warning("Axes dimensions are not equal. The visual diagonal is *not* the line of numerical congruence! Consider choosing identical values for xlim and ylim.")}#
	# define the defaults#
	if (is.null(points$show)) points$show <- TRUE#
	if (is.na(points$show)) {#
		if (is.null(points$data)) {#
			points$show <- FALSE	#
		} else {#
			points$show <- TRUE#
		}#
	}#
	if (is.null(points$value)) points$value <- "raw"#
	if (is.null(points$color)) points$color <- "black"#
	if (is.null(points$jitter)) points$jitter <- 0#
	if (is.null(points$cex)) points$cex <- 0.5#
	if (is.null(points$out.mark)) points$out.mark <- FALSE#
	if (points$show==TRUE & is.null(points$data)) {#
		warning("You must provide a data frame with the coordinates of the raw data points (points = list(show = TRUE, data = ???)). Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (is.null(contour$show)) contour$show <- TRUE#
	if (is.null(contour$color)) contour$color <- "grey40"#
	if (is.null(contour$highlight)) contour$highlight <- c()#
	type <- match.arg(type, c("interactive", "3d", "contour"))#
	surface <- match.arg(surface, c("predict", "smooth"))#
	points[["value"]] <- match.arg(points[["value"]], c("raw", "predicted"))#
#
	if (demo == FALSE) {#
			if (is.null(xlab)) xlab <- "X"#
			if (is.null(ylab)) ylab <- "Y"#
			if (is.null(zlab)) zlab <- "Z"#
			if (is.null(xlim)) {xlim <- c(-2.1, 2.1)}#
			if (is.null(ylim)) {ylim <- c(-2.1, 2.1)}#
	}#
	if (is.null(points$data) & surface == "smooth") {#
		warning("Smoothing only works if data points are provided (points=list(data=???))! Reverting to surface = 'predict'")#
		surface <- "predict"#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy,x3, xy2, x2y, y3)#
	if (!model %in% c("absunc", "absdiff")) {#
		if (!is.null(fit) & model != "cubic" & model != "null") {#
			SP <- RSA.ST(fit, model=model)#
		} else {#
			SP <- RSA.ST(x=x, y=y, xy=xy, x2=x2, y2=y2)#
		}#
		SP.text <- paste0("a", 1:4, ": ", f2(SP$SP$estimate, 2), sig2star(SP$SP$p.value), collapse="    ")#
	} else {#
		SP <- NULL#
		param <- FALSE#
		SP.text <- ""#
	}#
	# build data set#
	grid <- gridsize#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	if (surface == "predict") {#
		new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11, 15:18)]))#
	}#
	if (surface == "smooth") {#
		library(fields)#
		tpsfit <- Tps(points$data[, 1:2], points$data[, 3], scale.type="unscaled", lambda=lambda)#
		new2$z <- predict(tpsfit, new[, c("x", "y")])#
	}#
	# impose link functions#
	logit <- function (x) {log(x/(1-x))}#
	invlogit <- function (x) {1/(1+exp(-x))}#
	link <- match.arg(link, c("identity", "logit", "probit"))#
	if (link == "probit") {#
		z.trans <- 1.7 * new2$z#
		new2$z <- invlogit(z.trans)#
	}#
	if (link == "logit") {#
		new2$z <- invlogit(new2$z)#
	}#
#
	# determine zlim#
	if (!is.null(points$data) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(points$data[, 3], na.rm=TRUE)), max(max(new2$z, na.rm=TRUE), max(points$data[, 3], na.rm=TRUE)))#
	} else {#
		if (is.null(zlim)) zlim <- c(min(new2$z), max(new2$z))#
	}#
	zlim.final <- zlim#
	## Plots#
	if (bw == FALSE) {#
		# RdYlGn palette#
		if (is.null(pal)) {#
			pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
		}#
		gridCol <- ifelse(contour$show == TRUE, "grey60", "grey30")#
	} else {#
		if (is.null(pal)) {#
			pal <- colorRampPalette(c("#FFFFFF", "#AAAAAA", "#030303"), bias=2)(11)#
		}#
		gridCol <- ifelse(contour$show == TRUE, "grey30", "grey30")#
	}#
	if (length(pal) < 2) {legend <- FALSE}#
	# ---------------------------------------------------------------------#
	# Calculate positions of raw points#
#
	if (points$out.mark == TRUE & is.null(fit)) {#
		warning("Outliers can only be marked if an RSA-object is provided. Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (points$show == TRUE) {#
		if (points$out.mark == FALSE) {#
			data.used <- points$data#
		}#
		if (points$out.mark == TRUE & !is.null(fit)) {#
			data.used <- fit$data.original#
		}#
		if (points$value == "raw") {#
			zpoints <- as.vector(data.used[, 3])#
		} else if (points$value == "predicted") {#
			N <- colnames(data.used)#
			data.used2 <- add.variables(formula(paste0(N[3], " ~ ", N[1], "*", N[2])), data.used)#
			# calculate predicted values#
			zpoints <- b0 + colSums(C*t(data.used2[, c(#
				N[1],#
				N[2],#
				paste0(N[1], "2"),#
				paste0(N[2], "2"),#
				paste0(N[1], "_", N[2]),#
				"W",#
				paste0("W_", N[1]),#
				paste0("W_", N[2]),#
				paste0(N[1], "3"),#
				paste0(N[1], "_", N[2], "2"),#
				paste0(N[1], "2", "_", N[2]),#
				paste0(N[2], "3")#
			)]))#
			zpoints <- as.vector(zpoints)#
		}#
#
		xpoints <- as.vector(data.used[, 1])#
		ypoints <- as.vector(data.used[, 2])#
	}#
	# ---------------------------------------------------------------------#
	#  calculate bag plot: bag = outer, loop = inner#
	if (hull==TRUE) {#
		library(aplpack)#
		BAG <- compute.bagplot(xpoints, ypoints)#
		# close the polygon#
		h1 <- rbind(BAG$hull.bag, BAG$hull.bag[1, ])#
		h2 <- rbind(BAG$hull.loop, BAG$hull.loop[1, ])#
#
		# approx: interpolate the points of the bag (in order to get a more smooth fitting line on the z-axis)#
		minDist <- min(diff(xlim)/gridsize, diff(ylim)/gridsize)/2#
#
		h1 <- interpolatePolyon(h1[, 1], h1[, 2], minDist=minDist)	#
		h2 <- interpolatePolyon(h2[, 1], h2[, 2], minDist=minDist)	#
		# calculate predicted values#
		bagpoints <- add.variables(z~x+y, data.frame(x=h1$x, y=h1$y))#
		bagpoints$z <- b0 + colSums(C*t(bagpoints[, c(1:5, 9:11, 15:18)]))#
		bag <- data.frame(X  = bagpoints$x, Y  = bagpoints$y, Z = bagpoints$z)#
		looppoints <- add.variables(z~x+y, data.frame(x=h2$x, y=h2$y))#
		looppoints$z <- b0 + colSums(C*t(looppoints[, c(1:5, 9:11, 15:18)]))#
		loop <- data.frame(X  = looppoints$x, Y  = looppoints$y, Z = looppoints$z)			#
	}#
	## ======================================================================#
	## Interactive plot#
	## ======================================================================#
	if (type == "interactive") {#
		library(rgl)#
		P <- list(x=seq(xlim[1], xlim[2], length.out=grid), y=seq(ylim[1], ylim[2], length.out=grid))#
		DV2 <- matrix(new2$z, nrow=grid, ncol=grid, byrow=FALSE)#
		R <- range(DV2)#
		col2 <- as.character(cut(1:(R[2] - R[1] + 1), breaks=length(pal), labels=pal))#
		open3d()#
		rgl.viewpoint(-30, -90)#
		rgl.light(theta = 0, phi = 90, viewpoint.rel = TRUE, ambient = "#FF0000", diffuse = "#FFFFFF", specular = "#FFFFFF")#
		persp3d(P$x, P$y, DV2, xlab = xlab, ylab = ylab, zlab = zlab, color=col2[DV2 - R[1] + 1])#
#
		if (contour$show == TRUE) {#
		    contours <- contourLines(P, z=DV2)#
		     for (i in 1:length(contours)) {#
				 with(contours[[i]], lines3d(x, y, level, col=contour$color))#
			 }#
		 }#
		if (points$show == TRUE) {#
			if (points$out.mark == FALSE) {#
				points3d(data.frame(xpoints, ypoints, zpoints), col=points$color)#
			}#
			if (points$out.mark == TRUE & !is.null(fit)) {#
				colvec <- rep(points$color, nrow(fit$data.original))#
				colvec[fit$outliers] <- "red"#
				points3d(fit$data.original[, c(fit$IV1, fit$IV2, fit$DV)], col=colvec)#
				text3d(fit$data.original[fit$outliers, c(fit$IV1, fit$IV2, fit$DV)], col="red", texts="X")#
			} else {#
				warning("Please provide an RSA-object to mark outliers.")#
			}#
		}#
		p1 <- NULL	# no plot object is returned	#
	}	#
	## ======================================================================#
	## Wireframe plot#
	## ======================================================================#
	if (type == "3d") {#
			mypanel2 <- function(x, y, z, xlim, ylim, zlim, xlim.scaled, ylim.scaled, zlim.scaled, axes, x.points=NULL, y.points=NULL, z.points=NULL, SPs="", ...) {#
			   # rescale absolute x, y, and z values so that they fit into the box#
			   RESCALE <- function(n) {#
				  X2 <- xlim.scaled[1] + diff(xlim.scaled) * (n$X - xlim[1]) / diff(xlim)#
	              Y2 <- ylim.scaled[1] + diff(ylim.scaled) * (n$Y - ylim[1]) / diff(ylim)#
	              Z2 <- zlim.scaled[1] + diff(zlim.scaled) * (n$Z - zlim[1]) / diff(zlim)#
				  df <- data.frame(X=X2, Y=Y2, Z=Z2)#
				  df <- df[df$X >= min(xlim.scaled) & df$X <= max(xlim.scaled) & df$Y >= min(ylim.scaled) & df$Y <= max(ylim.scaled) &  df$Z >= min(zlim.scaled) & df$Z <= max(zlim.scaled), ]#
				  return(df)#
			   }#
			# ---------------------------------------------------------------------#
			# 1. Projection on bottom of cube#
			  if (project==TRUE) {#
				  for (a in axes) {#
					  #print(paste("Plotting projection of", names(a)))#
					  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1, Z=zlim.final[1] + .01))#
		              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
				  } #
			  }#
			   # ---------------------------------------------------------------------#
			   # 2. Borders, back part#
					if (border==TRUE) {#
						  # Make boundary of grid a bit thicker#
						  box1 <- new2[new2$y == max(new2$y), ]#
						  box2 <- new2[new2$y == min(new2$y), ]#
						  box3 <- new2[new2$x == max(new2$x), ]#
						  box4 <- new2[new2$x == min(new2$x), ]#
						  box <- rbind(data.frame(box1, side=1), data.frame(box2, side=2), data.frame(box3, side=3), data.frame(box4, side=4))#
			              x.box <- xlim.scaled[1] + diff(xlim.scaled) * (box$x - xlim[1]) / diff(xlim)#
			              y.box <- ylim.scaled[1] + diff(ylim.scaled) * (box$y - ylim[1]) / diff(ylim)#
			              z.box <- zlim.scaled[1] + diff(zlim.scaled) * (box$z - zlim[1]) / diff(zlim)#
						  # plot the back lines of the border#
			              panel.3dscatter(x = x.box[box$side==1], y = y.box[box$side==1], z = z.box[box$side==1], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
						  panel.3dscatter(x = x.box[box$side==3], y = y.box[box$side==3], z = z.box[box$side==3], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
					  }#
					  # ---------------------------------------------------------------------#
					  # 3. the surface#
						  panel.3dwire(x = x, y = y, z = z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                           xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
								   col=gridCol,  lwd=0.3, ...)#
					# ---------------------------------------------------------------------#
					# 4. plot of LOC and LOIC, and other axes#
						  for (a in axes) {#
							  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1))#
				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
						  }   #
  					# ---------------------------------------------------------------------#
  					# 4b. plot of maximum lines#
					if (maxlines == TRUE) {#
						# maximum X for a given Y#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[1]/C[5]), p1=-((2*C[3])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="red", lty="dashed", lwd=2, ...)#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[2]/(2*C[4])), p1=-((C[5])/(2*C[4]))))#
							  #a0 <- RESCALE(getIntersect2(p0=-(C[2]/C[5]), p1=-((2*C[4])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="blue", lty="dashed", lwd=2, ...)#
					}#
					# ---------------------------------------------------------------------#
					# 5. Borders, front part	  #
					   if (border==TRUE) {#
 						  # plot the front boundary lines#
 			              panel.3dscatter(x = x.box[box$side==2], y = y.box[box$side==2], z = z.box[box$side==2], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
						  panel.3dscatter(x = x.box[box$side==4], y = y.box[box$side==4], z = z.box[box$side==4], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
					   }#
						  if (param == TRUE) {#
							  grid.text(SPs, .02, .95, just="left")#
						  }  #
						# ---------------------------------------------------------------------#
						# 6a: The bag plot, if requested#
						if (hull==TRUE) {	#
							# bag (= inner bag)#
							if (any(bag$X < xlim[1] | bag$X > xlim[2] | bag$Y < ylim[1] | bag$Y > ylim[2])) {#
								warning("The bag is partly outside the plotting region. Bag is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  bag.rescale <- RESCALE(bag)#
		  		              panel.3dscatter(x = bag.rescale$X, y = bag.rescale$Y, z = bag.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="grey30", lty="dashed", lwd=2, ...)#
							}#
							# loop (= outer bag)#
							if (any(loop$X < xlim[1] | loop$X > xlim[2] | loop$Y < ylim[1] | loop$Y > ylim[2])) {#
								warning("The loop is partly outside the plotting region. Loop is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  loop.rescale <- RESCALE(loop)#
		  		              panel.3dscatter(x = loop.rescale$X, y = loop.rescale$Y, z = loop.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="black", lty="dashed", lwd=2, ...)#
							}#
						}	  	#
						# ---------------------------------------------------------------------#
						# 6b. Raw data points scatter plot	  #
					  		if (points$show == TRUE) {#
	  			              x2 <- xlim.scaled[1] + diff(xlim.scaled) * (x.points - xlim[1]) / diff(xlim)#
							  if (points$jitter > 0) x2 <- x2 + rnorm(length(x2), 0, points$jitter)#
	  			              y2 <- ylim.scaled[1] + diff(ylim.scaled) * (y.points - ylim[1]) / diff(ylim)#
							  if (points$jitter > 0) y2 <- y2 + rnorm(length(y2), 0, points$jitter)#
							  z2 <- zlim.scaled[1] + diff(zlim.scaled) * (z.points - zlim[1]) / diff(zlim)#
	  			              panel.3dscatter(x = x2, y = y2, z = z2, xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=20, col=points$color, cex=points$cex, ...)#
							  # plot outliers#
							  if (points$out.mark==TRUE) {#
	  			              	panel.3dscatter(x = x2[fit$outliers], y = y2[fit$outliers], z = z2[fit$outliers], xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=4, col="red", cex=points$cex, ...)#
							  }#
					  		}	#
					# ---------------------------------------------------------------------#
					# 7. plot contour lines:#
						if (contour$show == TRUE) {#
							cs <- ggplot(new2, aes_string(x="x", y="y", fill="z", z="z")) + stat_contour(bins=ifelse(length(pal)>1, length(pal)+1, 8))#
							cLines <- ggplot_build(cs)#
							C0 <- cLines$data[[1]][, c("x", "y", "level", "group")]#
							colnames(C0) <- c("X", "Y", "Z", "group")#
							for (cL in C0$group) {#
							  C1 <- RESCALE(C0[C0$group==cL, c("X", "Y", "Z")])#
				             panel.3dscatter(x = C1$X, y = C1$Y, z = C1$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                             xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=contour$color, lty="solid", lwd=1, ...)#
							}#
							# highlight specific contour lines?#
							if (length(contour$highlight) > 0) {#
								C2 <- C0[C0$Z %in% f0(unique(C0$Z), contour$highlight), ]#
								for (cL in C2$group) {#
								  C3 <- RESCALE(C2[C2$group==cL, c("X", "Y", "Z")])#
					              panel.3dscatter(x = C3$X, y = C3$Y, z = C3$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
					                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
												  type="l", col.line=contour$color, lty="solid", lwd=2, ...)#
								}#
							}#
						}#
				}#
				# local function: compute the surface line, defined by a line on the X-Y plane (p0 = intercept, p1=slope)#
				getIntersect2 <- function(p0, p1, Z=NULL) {#
					X <- seq(min(xlim), max(xlim), length.out=grid*2)#
					Y <- p0 + p1*X#
					n <- data.frame(X, Y)#
					n2 <- add.variables(z~X+Y, n)#
					n2$Z <- b0 + colSums(c(x, y, x2, y2, xy)*t(n2[, c(1:5)]))#
					if (!is.null(Z)) n2$Z <- Z#
					return(n2[, c("X", "Y", "Z")])#
				}#
				axesList <- list()#
				if ("LOC" %in% axes) {axesList[["LOC"]]  <- list(p0=0, p1=1, lty="solid", col="grey")}#
				if ("LOIC" %in% axes) {axesList[["LOIC"]] <- list(p0=0, p1=-1, lty="dotted", col="grey")}#
				if ("PA1" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA1")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA1"]] <- list(p0=SP2$p10, p1=SP2$p11, lty="solid", col="black")#
						} else {#
							axesList[["PA1"]] <- list(p0=SP$p10, p1=SP$p11, lty="solid", col="black")#
						}					#
				}#
				if ("PA2" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA2")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA2"]] <- list(p0=SP2$p20, p1=SP2$p21, lty="dotted", col="black")#
					} else {#
						axesList[["PA2"]] <- list(p0=SP$p20, p1=SP$p21, lty="dotted", col="black")	#
					}#
				}			#
				# Define color range: Relative to surface min/max, or relative to box (zlim)?#
				if (pal.range == "box") {#
					at <- seq(zlim[1], zlim[2], length.out=length(pal)-1)#
				} else if (pal.range == "surface") {#
					at <- seq(min(new2$z), max(new2$z), length.out=length(pal)-1)#
				}#
			if (points$show == FALSE) {#
				p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation, #
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2, ...)#
				#p1#
			} else {#
				p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation,#
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2,#
					x.points=xpoints, y.points=ypoints, z.points=zpoints, ...)#
			}#
	}  # of type == "3d"#
	## ======================================================================#
	## Contour plot#
	## ======================================================================#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			# Define color range: Relative to surface min/max, or relative to box (zlim)?#
			if (pal.range == "box") {#
				limits <- c(zlim[1], zlim[2])#
			} else if (pal.range == "surface") {#
				limits <- c(min(new2$z), max(new2$z))#
			}#
			p1 <- ggplot(new2, aes_string(x="x", y="y", z="z")) + geom_tile(aes_string(fill="z")) + scale_fill_gradientn(zlab, colours=pal, limits=limits) + theme_bw() + theme(aspect.ratio=1) + xlab(xlab) + ylab(ylab)#
			if (legend==FALSE) {#
				p1 <- p1 + guides(fill=FALSE)#
			}#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# highlight specific contour lines?#
			if (length(contour$highlight) > 0) {#
				cLines <- ggplot_build(p1)#
				C0 <- cLines$data[[2]][, c("x", "y", "level", "group")]#
#
				# Find closest values in contours#
				C1 <- C0[C0$level %in% f0(unique(C0$level), contour$highlight), ]#
				p1 <- p1 + geom_path(data=C1, aes_string(x="x", y="y", group="group", z="level"), size=1.1)#
			}#
			# (in)congruence lines#
			if ("LOC" %in% axes) {#
				p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey")#
			}#
			if ("LOIC" %in% axes) {#
				p1 <- p1 + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			}#
			if (("PA1" %in% axes) & !any(is.na(SP[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=data.frame(SP[c("p10", "p11")]), aes_string(intercept="p10", slope="p11"))#
			}#
			if (("PA2" %in% axes) & !any(is.na(SP[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=data.frame(SP[c("p20", "p21")]), aes_string(intercept="p20", slope="p21"), linetype="dotted")#
			}#
			if (param==TRUE & !any(is.na(SP[c("X0", "Y0")])) & !model %in% c("RR", "sqdiff", "SSD", "SRSD", "SRR", "SRRR")) {#
				p1 <- p1 + annotate("point", x=SP$X0, y=SP$Y0, z=max(new2$z))#
			}#
			if (points$show == TRUE) {#
				if (points$out.mark==FALSE) {#
					p1 <- p1 + annotate("point", x=xpoints, y=ypoints, color=points$color, size=3*points$cex)#
				}#
				if (points$out.mark==TRUE) {#
					colvec <- rep(points$color, nrow(fit$data.original))#
					colvec[fit$outliers] <- "red"#
					shapevec <- rep(19, nrow(fit$data.original))#
					shapevec[fit$outliers] <- 4#
					p1 <- p1 + annotate("point", x=fit$data.original[, fit$IV1], y=fit$data.original[, fit$IV2], color=colvec, size=3*points$cex, shape=shapevec)#
				}#
			}#
			if (hull==TRUE & !is.null(points$data)) {#
				p1 <- p1 + annotate("path", x=bag$X, y=bag$Y, linetype="dashed", color="grey10")#
				p1 <- p1 + annotate("path", x=loop$X, y=loop$Y, linetype="dotted", color="grey10")#
			}#
			# plot CI of SP#
			if (param==TRUE & SP.CI==TRUE & !is.null(fit)) {#
				PAR <- getPar(fit, "coef", model=model)#
				p1 <- p1 + annotate("errorbar", x=SP$X0, y=SP$Y0, ymin=PAR[PAR$label=="Y0", "ci.lower"], ymax=PAR[PAR$label=="Y0", "ci.upper"], z=max(new2$z), width=.3)#
				p1 <- p1 + annotate("errorbarh", x=SP$X0, y=SP$Y0, xmin=PAR[PAR$label=="X0", "ci.lower"], xmax=PAR[PAR$label=="X0", "ci.upper"], z=max(new2$z), height=.3)#
			}#
		}#
	}#
	return(p1)#
}#
#' @S3method plot RSA#
#
# Purpose: Extract the model parameters, xlim, xlab, etc. from the fitted object and give it to the plotRSA function#
plot.RSA <- function(x, ...) {#
	fit <- x#
	extras <- match.call(expand.dots = FALSE)$...#
	if (is.null(extras)) extras <- list()#
	if (is.null(extras$model)) extras$model <- "full"#
	C <- coef(fit$models[[extras$model]])#
	if (fit$models[[extras$model]]@Options$estimator != "DWLS") {#
		extras$b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), 0, C[paste0(fit$DV, "~1")]))#
	} else {			#
		# the threshold is the negative of the intercept ...#
		extras$b0 <- -as.numeric(ifelse(is.na(C[paste0(fit$DV, "|t1")]), 0, C[paste0(fit$DV, "|t1")]))#
	}#
	extras$x <- as.numeric(ifelse(is.na(C["b1"]), 0, C["b1"]))#
	extras$y <- as.numeric(ifelse(is.na(C["b2"]), 0, C["b2"]))#
	extras$x2 <- as.numeric(ifelse(is.na(C["b3"]), 0, C["b3"]))#
	extras$y2 <- as.numeric(ifelse(is.na(C["b5"]), 0, C["b5"]))#
	extras$xy <- as.numeric(ifelse(is.na(C["b4"]), 0, C["b4"]))#
	extras$w <- as.numeric(ifelse(is.na(C["b6"]), 0, C["b6"]))#
	extras$wx <- as.numeric(ifelse(is.na(C["b7"]), 0, C["b7"]))#
	extras$wy <- as.numeric(ifelse(is.na(C["b8"]), 0, C["b8"]))#
	# cubic parameters#
	extras$x3 <- as.numeric(ifelse(is.na(C["b9"]), 0, C["b9"]))#
	extras$xy2 <- as.numeric(ifelse(is.na(C["b10"]), 0, C["b10"]))#
	extras$x2y <- as.numeric(ifelse(is.na(C["b11"]), 0, C["b11"]))#
	extras$y3 <- as.numeric(ifelse(is.na(C["b12"]), 0, C["b12"]))#
#
	if (is.null(extras$xlim)) {#
		extras$xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
		# expand range by 20% at each end#
		extras$xlim[1] <- extras$xlim[1]*ifelse(extras$xlim[1]<0, 1.1, 0.9)#
		extras$xlim[2] <- extras$xlim[2]*ifelse(extras$xlim[2]<0, 0.9, 1.1)#
	}#
	if (is.null(extras$ylim)) {#
		extras$ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
		extras$ylim[1] <- extras$ylim[1]*ifelse(extras$ylim[1]<0, 1.1, 0.9)#
		extras$ylim[2] <- extras$ylim[2]*ifelse(extras$ylim[2]<0, 0.9, 1.1)#
	}#
	# for the correct visual diagonal: same range for X and Y#
	extras$xlim[1] <- extras$ylim[1] <- min(extras$xlim[1], extras$ylim[1])#
	extras$xlim[2] <- extras$ylim[2] <- max(extras$xlim[2], extras$ylim[2])#
	if (is.null(extras$xlab)) extras$xlab <- fit$IV1#
	if (is.null(extras$ylab)) extras$ylab <- fit$IV2#
	if (is.null(extras$zlab)) extras$zlab <- fit$DV#
	if (is.null(extras$points)) {#
		extras$points <- list(show=TRUE, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE)#
	}#
	extras$points$data <- fit$data[, c(fit$IV1, fit$IV2, fit$DV, colnames(fit$data)[which(!colnames(fit$data) %in% c(fit$IV1, fit$IV2, fit$DV))])]#
	extras$fit <- fit#
	do.call(plotRSA, as.list(extras))#
}#
#plot(r1, type="3d", points=list(show=TRUE, cex=2))#
#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, points=list(data=data.frame(x=-1:3, y=-1:3, z=0), show=TRUE))#
#
#plot(r1)#
#plot(r1, points=list(show=TRUE))#
#plotRSA(x=.05, x2=.1, xy=.20, type="3", gridsize=21)#
#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="3d", points=list(show=TRUE), rotation=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, type="3d")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, legend=FALSE, type="3d")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, legend=FALSE, type="c")#
#
#RSA.ST(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102)#
## Minimal example#
#x <- y <- z <- c(1,2,3)#
#df <- data.frame(x, y, z)#
#wireframe(z ~ x*y, df,  scales = list(arrows = FALSE, col = "black", font = 1, tck = c(1, 1, 1), distance =c(1, 1, 1)))#
##
##
#xyplot(z ~ x, df,  scales = list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck), par.settings=list(axis.components=list(left=list(pad1=2))))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="r"))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p"))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-2, 2)#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p"))
rawpoints <- dat1[, c("status_m", "status_w", "ras_m")]#
limits0 <- abs(c(range(rawpoints[, 1]), range(rawpoints[, 2])))#
limits <- max(limits0)*c(-1, 1)#
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-2, 2),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p"))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p"))
nrow(rawpoints)
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.5))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.1))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.05))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.01))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.01))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.01))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.01))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.01))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.01))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.01))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.01))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.01))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.01))
?plotRSA
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="3",#
	hull=TRUE,#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))
plotRSA(x=eff["b1m"], y=eff["b2m"], x2=eff["b3m"], xy=eff["b4m"], y2=eff["b5m"], #
	param=FALSE, legend=FALSE, #
	xlim=limits,#
	ylim=limits,#
	zlim=c(-1.5, 1.5),#
	xlab="Male status", ylab="Female status", zlab="Relationship satisfaction",#
	axes=c("LOC", "LOIC"),#
	type="c",#
	hull=TRUE,#
	points=list(show=TRUE, data=rawpoints, value="p", jitter=0.005))#
# ---------------------------------------------------------------------#
# Results:#
# "Zero-Sum Effect"#
##
# Z = b_1 * (X + Y)^2#
# Ridge is on X + Y == 0 (i.e., line of incongruence).#
# D.h., wenn Paare in ihrem Mittelwert im Durchschnitt sind (z=0), dann sind sie am zufriedensten.#
# Wobei niedrige Kongruenz (beide unterdurchschnittlich) etwas schlimmer ist als hohe Kongruent (beide berdurchschnittlich)
summary(fit2)
plot(r1, surface="smooth")
plot(r1, surface="smooth", zlim=c(-1.5, 1.5))
plot(r1, surface="smooth", zlim=c(-1.5, 1.5), lambda=2)
plot(r1, surface="smooth", zlim=c(-1.5, 1.5), lambda=1.5)
plot(r1, surface="smooth", zlim=c(-1.5, 1.5), lambda=1)
plot(r1, surface="smooth", zlim=c(-1.5, 1.5), lambda=3)
plot(r1, surface="smooth", zlim=c(-1.5, 1.5), lambda=4)
plot(surface="smooth", zlim=c(-1.5, 1.5), lambda=4, points=list(show=TRUE, data=dat1[, c("ras_m", "status_m", "status_w")]))
options(error=recover)
plot(surface="smooth", zlim=c(-1.5, 1.5), lambda=4, points=list(show=TRUE, data=dat1[, c("ras_m", "status_m", "status_w")]))
ls()
x
y
xlab
ylab
ls()
axes
x
plot(surface="smooth", zlim=c(-1.5, 1.5), lambda=4, points=list(show=TRUE, data=dat1[, c("ras_m", "status_m", "status_w")]))
ls()
x
y
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
define the defaults#
	if (is.null(points$show)) points$show <- TRUE#
	if (is.na(points$show)) {#
		if (is.null(points$data)) {#
			points$show <- FALSE	#
		} else {#
			points$show <- TRUE#
		}#
	}#
	if (is.null(points$value)) points$value <- "raw"#
	if (is.null(points$color)) points$color <- "black"#
	if (is.null(points$jitter)) points$jitter <- 0#
	if (is.null(points$cex)) points$cex <- 0.5#
	if (is.null(points$out.mark)) points$out.mark <- FALSE#
	if (points$show==TRUE & is.null(points$data)) {#
		warning("You must provide a data frame with the coordinates of the raw data points (points = list(show = TRUE, data = ???)). Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (is.null(contour$show)) contour$show <- TRUE#
	if (is.null(contour$color)) contour$color <- "grey40"#
	if (is.null(contour$highlight)) contour$highlight <- c()
options(error=NULL)
plotRSA(surface="smooth", zlim=c(-1.5, 1.5), lambda=4, points=list(show=TRUE, data=dat1[, c("ras_m", "status_m", "status_w")]))
plot(r1, surface="smooth")
plot(r1, surface="smooth", zlim=c(-1.5, 1.5), lambda=4)
plotRSA(surface="smooth", zlim=c(-1.5, 1.5), lambda=4, points=list(show=TRUE, data=dat1[, c("ras_m", "status_m", "status_w")]))
plotRSA(surface="smooth", zlim=c(-1.5, 1.5), lambda=4, points=list(show=TRUE, data=dat1[, c("status_m", "status_w", "ras_m")]))
plot(r1, surface="smooth", zlim=c(-1.5, 1.5), lambda=4)
plotRSA(surface="smooth", zlim=c(-1.5, 1.5), lambda=4, points=list(show=TRUE, data=dat1[, c("status_m", "status_w", "ras_m")]))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters#
#'#
#' @details#
#' Each plot type has its distinctive advantages. The two-dimensional contour plot gives a clear view of the position of the principal axes and the stationary point. The 3d plot gives a three dimensional impression of the surface, allows overplotting of the original data points (in case an RSA object is provided), and allows the interactive adjustment of regression weights in the \code{\link{demoRSA}} function. The interactive plot allows rotating and exploring a three-dimensional surface with the mouse (nice for demonstration purposes).#
#' If you want to export publication-ready plots, it is recommended to export it with following commands:#
#' \code{p1 <- plot(r1, bw=TRUE)#
#' trellis.device(device="cairo_pdf", filename="RSA_plot.pdf")#
#' print(p1)#
#' dev.off()}#
#'#
#' @aliases plotRSA#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param y3 Y^3 coefficient#
#' @param x3 X^3 coefficient#
#' @param xy2 XY^2 coefficient#
#' @param x2y X^2Y coefficient#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param xlab Label for x axis#
#' @param ylab Label for y axis#
#' @param zlab Label for z axis#
#' @param surface Method for the calculation of the surface z values. "predict" takes the predicted values from the model, "smooth" uses a thin plate smoother (function \code{Tps} from the \code{fields} package) of the raw data#
#' @param lambda lambda parameter for the smoother. Default (NULL) means that it is estimated by the smoother function. Small lambdas around 1 lead to rugged surfaces, big lambdas to very smooth surfaces.#
#' @param rotation Rotation of the 3d surface plot (when type == "3d")#
#' @param label.rotation Rotation of the axis labls (when type == "3d")#
#' @param gridsize Number of grid nodes in each dimension#
#' @param bw Print surface in black and white instead of colors?#
#' @param legend Print color legend for z values?#
#' @param cex Font size factor for axes labels#
#' @param type \code{3d} for 3d surface plot, \code{contour} for 2d contour plot, "interactive" for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient#
#' @param points A list of parameters which define the appearance of the raw scatter points: #
#'	\itemize{#
#'		\item{data: Data frame which contains the coordinates of the raw data points. FIrst column = x, second = y, third = z. This data frame is automatically generated when the plot is based on a fitted RSA-object}#
#'		\item{show = TRUE: Should the original data points be overplotted?}#
#' 		\item{value="raw": Plot the original z value, "predicted": plot the predicted z value}#
#'		\item{jitter = 0: Amount of jitter for the raw data points. For z values, a value of 0.005 is reasonable}#
#'		\item{cex = .5: multiplication factor for point size}#
#' 		\item{out.mark = FALSE: If set to TRUE, outliers according to Bollen & Jackman (1980) are printed as red X symbols. This option works regardless of whether the RSA function has set out.rm to TRUE or FALSE: #
#'			\itemize{#
#'				\item{If out.rm == TRUE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is removed from the model and *not plotted* in plotRSA.}#
#'				\item{If out.rm == TRUE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is removed from the model but plotted and marked in plotRSA.}#
#'				\item{If out.rm == FALSE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is not removed from the model and plotted as a normal point in plotRSA (but not marked as outlier).}#
#'				\item{If out.rm == FALSE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is not removed from the model, but plotted and marked in plotRSA.}#
#'				\item{Example syntax: \code{plotRSA(r1, points=list(show=TRUE, out.mark=TRUE))}}#
#'		}}#
#'	}#
#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param demo Do not change that parameter (internal use only)#
#' @param fit Do not change that parameter (internal use only)#
#' @param param Should the surface parameters a1 to a4 be shown on the plot? In case of a 3d plot a1 to a4 are printed on the upper left side; in case of a contour plot the principal axes are plotted.#
#' @param axes A vector of strings specifying the axes that should be plotted. Can be any combination of c("LOC", "LOIC", "PA1", "PA2"). LOC = line of congruence, LOIC = line of incongruence, PA1 = first principal axis, PA2 = second principal axis#
#' @param project Should the LOC, LOIC, etc. (as defined in parameter \code{axes}) be also plotted as a projection on the bottom of the cube?#
#' @param maxlines Should the maximum lines be plotted? (red: maximum X for a given Y, blue: maximum Y for a given X). Works only in type="3d"#
#' @param link Link function to transform the z axes. Implemented are "identity" (no transformation; default), "probit", and "logit"#
#' @param border Should a thicker border around the surface be plotted? Sometimes this border leaves the surrounding box, which does not look good. In this case the border can be suppressed by setting \code{border=FALSE}.#
#' @param contour A list defining the appearance of contour lines (aka. height lines). show=TRUE: Should the contour lines be plotted on the 3d wireframe plot? (Parameter only relevant for \code{type="3d"}). color = "grey40": Color of the contour lines. highlight = c(): A vector of heights which should be highlighted (i.e., printed in bold). Be careful: the highlighted line is not necessarily exactly at the specified height; instead the nearest height line is selected.#
#' @param hull Plot a bag plot on the surface (This is a bivariate extension of the boxplot. 50% of points are in the inner bag, 50% in the outer region). See Rousseeuw, Ruts, & Tukey (1999).#
#' @param SP.CI Plot the CI of the stationary point (only relevant for \code{type="contour"})#
#' @param distance A vector of three values defining the distance of labels to the axes#
#' @param tck A vector of three values defining the position of labels to the axes (see ?wireframe)#
#' @param pal A palette for shading#
#' @param pal.range Should the color range be scaled to the box (\code{pal.range = "box"}, default), or to the min and max of the surface (\code{pal.range = "surface"})? If set to "box", different surface plots can be compared along their color, as long as the zlim is the same for both.#
#' @param pad Pad controls the margin around the figure (positive numbers: larger margin, negative numbers: smaller margin)#
#'#' @param ... Additional parameters passed to the plotting function (e.g., sub="Title"). A useful title might be the R squared of the plotted model: sub = as.expression(bquote(R^2==.(round(getPar(x, "r2", model="full"), 3))))#
#'#
#' @references#
#' Rousseeuw, P. J., Ruts, I., & Tukey, J. W. (1999). The Bagplot: A Bivariate Boxplot. The American Statistician, 53(4), 382-387. doi:10.1080/00031305.1999.10474494#
#' @seealso \code{\link{demoRSA}}, \code{\link{RSA}}#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' # Default: 3d plot:#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628)#
#' # Contour plot:#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="c")#
#' # Interactive plot (try the mouse!):#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="i")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df, models=c("sqdiff", "full", "IA"))#
#' plot(r1)	# default: model = "full"#
#' plot(r1, model="sqdiff", points=list(show=TRUE, value="predicted"))#
#b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-2, 2); ylim=c(-2, 2); rotation=list(x=-45, y=45, z=35); legend=TRUE; cex=1.2; type="3d"; points=TRUE; demo=FALSE; model="full"; #
#
#b0=-9; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=1; wy=-1;  zlim=NULL; xlim=c(-2, 2); ylim=c(-2, 2); rotation=list(x=-45, y=45, z=35); legend=TRUE; cex=1.2; type="3d"; points=TRUE; demo=FALSE; model="full"; fit=NULL; link="identity"; param=TRUE; gridsize=21;bw=FALSE; pal=NULL; axes=c("LOC", "LOIC", "PA1", "PA2"); distance=c(1, 1, 1); tck=c(1, 1, 1); xlab="X"; ylab="Y"; zlab="Z"; border=TRUE;#
#
## old rotation#
# rotation=list(x=-45, y=45, z=35), label.rotation=list(x=45, y=-25, z=94)#
# distance=c(1, 1, 1), tck=c(1, 1, 1)#
#
plotRSA <- function(x=0, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, x3=0, xy2=0, x2y=0, y3=0, b0=0, type="3d", model="full", #
	xlim=NULL, ylim=NULL, zlim=NULL, xlab=NULL, ylab=NULL, zlab=NULL, #
	surface="predict", lambda=NULL, #
	rotation=list(x=-63, y=32, z=15), label.rotation=list(x=19, y=-40, z=92), #
	gridsize=21, bw=FALSE, legend=TRUE, param=TRUE, #
	axes=c("LOC", "LOIC", "PA1", "PA2"), project=FALSE, maxlines=FALSE,#
	cex=1.2,#
	points = list(data=NULL, show=NA, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE),#
	demo=FALSE, fit=NULL, link="identity", #
	tck=c(1.5, 1.5, 1.5), distance=c(1.3, 1.3, 1.4), border=TRUE, #
	contour = list(show=FALSE, color="grey40", highlight = c()),#
	hull=FALSE, SP.CI=FALSE, #
	pal=NULL, pal.range="box", #
	pad=0, ...) {#
	if (!identical(xlim, ylim)) {warning("Axes dimensions are not equal. The visual diagonal is *not* the line of numerical congruence! Consider choosing identical values for xlim and ylim.")}#
	# define the defaults#
	if (is.null(points$show)) points$show <- TRUE#
	if (is.na(points$show)) {#
		if (is.null(points$data)) {#
			points$show <- FALSE	#
		} else {#
			points$show <- TRUE#
		}#
	}#
	if (is.null(points$value)) points$value <- "raw"#
	if (is.null(points$color)) points$color <- "black"#
	if (is.null(points$jitter)) points$jitter <- 0#
	if (is.null(points$cex)) points$cex <- 0.5#
	if (is.null(points$out.mark)) points$out.mark <- FALSE#
	if (points$show==TRUE & is.null(points$data)) {#
		warning("You must provide a data frame with the coordinates of the raw data points (points = list(show = TRUE, data = ???)). Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (is.null(contour$show)) contour$show <- TRUE#
	if (is.null(contour$color)) contour$color <- "grey40"#
	if (is.null(contour$highlight)) contour$highlight <- c()#
	type <- match.arg(type, c("interactive", "3d", "contour"))#
	surface <- match.arg(surface, c("predict", "smooth"))#
	points[["value"]] <- match.arg(points[["value"]], c("raw", "predicted"))#
#
	if (demo == FALSE) {#
			if (is.null(xlab)) xlab <- "X"#
			if (is.null(ylab)) ylab <- "Y"#
			if (is.null(zlab)) zlab <- "Z"#
			if (is.null(xlim)) {xlim <- c(-2.1, 2.1)}#
			if (is.null(ylim)) {ylim <- c(-2.1, 2.1)}#
	}#
	if (is.null(points$data) & surface == "smooth") {#
		warning("Smoothing only works if data points are provided (points=list(data=???))! Reverting to surface = 'predict'")#
		surface <- "predict"#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy,x3, xy2, x2y, y3)#
	if (!model %in% c("absunc", "absdiff")) {#
		if (!is.null(fit) & model != "cubic" & model != "null") {#
			SP <- RSA.ST(fit, model=model)#
		} else {#
			SP <- RSA.ST(x=x, y=y, xy=xy, x2=x2, y2=y2)#
		}#
		SP.text <- paste0("a", 1:4, ": ", f2(SP$SP$estimate, 2), sig2star(SP$SP$p.value), collapse="    ")#
	} else {#
		SP <- NULL#
		param <- FALSE#
		SP.text <- ""#
	}#
	# build data set#
	grid <- gridsize#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	if (surface == "predict") {#
		new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11, 15:18)]))#
	}#
	if (surface == "smooth") {#
		library(fields)#
		tpsfit <- Tps(points$data[, 1:2], points$data[, 3], scale.type="unscaled", lambda=lambda)#
		new2$z <- predict(tpsfit, new[, c("x", "y")])#
		param <- FALSE#
		axes <- ""#
	}#
	# impose link functions#
	logit <- function (x) {log(x/(1-x))}#
	invlogit <- function (x) {1/(1+exp(-x))}#
	link <- match.arg(link, c("identity", "logit", "probit"))#
	if (link == "probit") {#
		z.trans <- 1.7 * new2$z#
		new2$z <- invlogit(z.trans)#
	}#
	if (link == "logit") {#
		new2$z <- invlogit(new2$z)#
	}#
#
	# determine zlim#
	if (!is.null(points$data) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(points$data[, 3], na.rm=TRUE)), max(max(new2$z, na.rm=TRUE), max(points$data[, 3], na.rm=TRUE)))#
	} else {#
		if (is.null(zlim)) zlim <- c(min(new2$z), max(new2$z))#
	}#
	zlim.final <- zlim#
	## Plots#
	if (bw == FALSE) {#
		# RdYlGn palette#
		if (is.null(pal)) {#
			pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
		}#
		gridCol <- ifelse(contour$show == TRUE, "grey60", "grey30")#
	} else {#
		if (is.null(pal)) {#
			pal <- colorRampPalette(c("#FFFFFF", "#AAAAAA", "#030303"), bias=2)(11)#
		}#
		gridCol <- ifelse(contour$show == TRUE, "grey30", "grey30")#
	}#
	if (length(pal) < 2) {legend <- FALSE}#
	# ---------------------------------------------------------------------#
	# Calculate positions of raw points#
#
	if (points$out.mark == TRUE & is.null(fit)) {#
		warning("Outliers can only be marked if an RSA-object is provided. Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (points$show == TRUE) {#
		if (points$out.mark == FALSE) {#
			data.used <- points$data#
		}#
		if (points$out.mark == TRUE & !is.null(fit)) {#
			data.used <- fit$data.original#
		}#
		if (points$value == "raw") {#
			zpoints <- as.vector(data.used[, 3])#
		} else if (points$value == "predicted") {#
			N <- colnames(data.used)#
			data.used2 <- add.variables(formula(paste0(N[3], " ~ ", N[1], "*", N[2])), data.used)#
			# calculate predicted values#
			zpoints <- b0 + colSums(C*t(data.used2[, c(#
				N[1],#
				N[2],#
				paste0(N[1], "2"),#
				paste0(N[2], "2"),#
				paste0(N[1], "_", N[2]),#
				"W",#
				paste0("W_", N[1]),#
				paste0("W_", N[2]),#
				paste0(N[1], "3"),#
				paste0(N[1], "_", N[2], "2"),#
				paste0(N[1], "2", "_", N[2]),#
				paste0(N[2], "3")#
			)]))#
			zpoints <- as.vector(zpoints)#
		}#
#
		xpoints <- as.vector(data.used[, 1])#
		ypoints <- as.vector(data.used[, 2])#
	}#
	# ---------------------------------------------------------------------#
	#  calculate bag plot: bag = outer, loop = inner#
	if (hull==TRUE) {#
		library(aplpack)#
		BAG <- compute.bagplot(xpoints, ypoints)#
		# close the polygon#
		h1 <- rbind(BAG$hull.bag, BAG$hull.bag[1, ])#
		h2 <- rbind(BAG$hull.loop, BAG$hull.loop[1, ])#
#
		# approx: interpolate the points of the bag (in order to get a more smooth fitting line on the z-axis)#
		minDist <- min(diff(xlim)/gridsize, diff(ylim)/gridsize)/2#
#
		h1 <- interpolatePolyon(h1[, 1], h1[, 2], minDist=minDist)	#
		h2 <- interpolatePolyon(h2[, 1], h2[, 2], minDist=minDist)	#
		# calculate predicted values#
		bagpoints <- add.variables(z~x+y, data.frame(x=h1$x, y=h1$y))#
		bagpoints$z <- b0 + colSums(C*t(bagpoints[, c(1:5, 9:11, 15:18)]))#
		bag <- data.frame(X  = bagpoints$x, Y  = bagpoints$y, Z = bagpoints$z)#
		looppoints <- add.variables(z~x+y, data.frame(x=h2$x, y=h2$y))#
		looppoints$z <- b0 + colSums(C*t(looppoints[, c(1:5, 9:11, 15:18)]))#
		loop <- data.frame(X  = looppoints$x, Y  = looppoints$y, Z = looppoints$z)			#
	}#
	## ======================================================================#
	## Interactive plot#
	## ======================================================================#
	if (type == "interactive") {#
		library(rgl)#
		P <- list(x=seq(xlim[1], xlim[2], length.out=grid), y=seq(ylim[1], ylim[2], length.out=grid))#
		DV2 <- matrix(new2$z, nrow=grid, ncol=grid, byrow=FALSE)#
		R <- range(DV2)#
		col2 <- as.character(cut(1:(R[2] - R[1] + 1), breaks=length(pal), labels=pal))#
		open3d()#
		rgl.viewpoint(-30, -90)#
		rgl.light(theta = 0, phi = 90, viewpoint.rel = TRUE, ambient = "#FF0000", diffuse = "#FFFFFF", specular = "#FFFFFF")#
		persp3d(P$x, P$y, DV2, xlab = xlab, ylab = ylab, zlab = zlab, color=col2[DV2 - R[1] + 1])#
#
		if (contour$show == TRUE) {#
		    contours <- contourLines(P, z=DV2)#
		     for (i in 1:length(contours)) {#
				 with(contours[[i]], lines3d(x, y, level, col=contour$color))#
			 }#
		 }#
		if (points$show == TRUE) {#
			if (points$out.mark == FALSE) {#
				points3d(data.frame(xpoints, ypoints, zpoints), col=points$color)#
			}#
			if (points$out.mark == TRUE & !is.null(fit)) {#
				colvec <- rep(points$color, nrow(fit$data.original))#
				colvec[fit$outliers] <- "red"#
				points3d(fit$data.original[, c(fit$IV1, fit$IV2, fit$DV)], col=colvec)#
				text3d(fit$data.original[fit$outliers, c(fit$IV1, fit$IV2, fit$DV)], col="red", texts="X")#
			} else {#
				warning("Please provide an RSA-object to mark outliers.")#
			}#
		}#
		p1 <- NULL	# no plot object is returned	#
	}	#
	## ======================================================================#
	## Wireframe plot#
	## ======================================================================#
	if (type == "3d") {#
			mypanel2 <- function(x, y, z, xlim, ylim, zlim, xlim.scaled, ylim.scaled, zlim.scaled, axes, x.points=NULL, y.points=NULL, z.points=NULL, SPs="", ...) {#
			   # rescale absolute x, y, and z values so that they fit into the box#
			   RESCALE <- function(n) {#
				  X2 <- xlim.scaled[1] + diff(xlim.scaled) * (n$X - xlim[1]) / diff(xlim)#
	              Y2 <- ylim.scaled[1] + diff(ylim.scaled) * (n$Y - ylim[1]) / diff(ylim)#
	              Z2 <- zlim.scaled[1] + diff(zlim.scaled) * (n$Z - zlim[1]) / diff(zlim)#
				  df <- data.frame(X=X2, Y=Y2, Z=Z2)#
				  df <- df[df$X >= min(xlim.scaled) & df$X <= max(xlim.scaled) & df$Y >= min(ylim.scaled) & df$Y <= max(ylim.scaled) &  df$Z >= min(zlim.scaled) & df$Z <= max(zlim.scaled), ]#
				  return(df)#
			   }#
			# ---------------------------------------------------------------------#
			# 1. Projection on bottom of cube#
			  if (project==TRUE) {#
				  for (a in axes) {#
					  #print(paste("Plotting projection of", names(a)))#
					  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1, Z=zlim.final[1] + .01))#
		              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
				  } #
			  }#
			   # ---------------------------------------------------------------------#
			   # 2. Borders, back part#
					if (border==TRUE) {#
						  # Make boundary of grid a bit thicker#
						  box1 <- new2[new2$y == max(new2$y), ]#
						  box2 <- new2[new2$y == min(new2$y), ]#
						  box3 <- new2[new2$x == max(new2$x), ]#
						  box4 <- new2[new2$x == min(new2$x), ]#
						  box <- rbind(data.frame(box1, side=1), data.frame(box2, side=2), data.frame(box3, side=3), data.frame(box4, side=4))#
			              x.box <- xlim.scaled[1] + diff(xlim.scaled) * (box$x - xlim[1]) / diff(xlim)#
			              y.box <- ylim.scaled[1] + diff(ylim.scaled) * (box$y - ylim[1]) / diff(ylim)#
			              z.box <- zlim.scaled[1] + diff(zlim.scaled) * (box$z - zlim[1]) / diff(zlim)#
						  # plot the back lines of the border#
			              panel.3dscatter(x = x.box[box$side==1], y = y.box[box$side==1], z = z.box[box$side==1], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
						  panel.3dscatter(x = x.box[box$side==3], y = y.box[box$side==3], z = z.box[box$side==3], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
					  }#
					  # ---------------------------------------------------------------------#
					  # 3. the surface#
						  panel.3dwire(x = x, y = y, z = z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                           xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
								   col=gridCol,  lwd=0.3, ...)#
					# ---------------------------------------------------------------------#
					# 4. plot of LOC and LOIC, and other axes#
						  for (a in axes) {#
							  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1))#
				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
						  }   #
  					# ---------------------------------------------------------------------#
  					# 4b. plot of maximum lines#
					if (maxlines == TRUE) {#
						# maximum X for a given Y#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[1]/C[5]), p1=-((2*C[3])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="red", lty="dashed", lwd=2, ...)#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[2]/(2*C[4])), p1=-((C[5])/(2*C[4]))))#
							  #a0 <- RESCALE(getIntersect2(p0=-(C[2]/C[5]), p1=-((2*C[4])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="blue", lty="dashed", lwd=2, ...)#
					}#
					# ---------------------------------------------------------------------#
					# 5. Borders, front part	  #
					   if (border==TRUE) {#
 						  # plot the front boundary lines#
 			              panel.3dscatter(x = x.box[box$side==2], y = y.box[box$side==2], z = z.box[box$side==2], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
						  panel.3dscatter(x = x.box[box$side==4], y = y.box[box$side==4], z = z.box[box$side==4], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
					   }#
						  if (param == TRUE) {#
							  grid.text(SPs, .02, .95, just="left")#
						  }  #
						# ---------------------------------------------------------------------#
						# 6a: The bag plot, if requested#
						if (hull==TRUE) {	#
							# bag (= inner bag)#
							if (any(bag$X < xlim[1] | bag$X > xlim[2] | bag$Y < ylim[1] | bag$Y > ylim[2])) {#
								warning("The bag is partly outside the plotting region. Bag is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  bag.rescale <- RESCALE(bag)#
		  		              panel.3dscatter(x = bag.rescale$X, y = bag.rescale$Y, z = bag.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="grey30", lty="dashed", lwd=2, ...)#
							}#
							# loop (= outer bag)#
							if (any(loop$X < xlim[1] | loop$X > xlim[2] | loop$Y < ylim[1] | loop$Y > ylim[2])) {#
								warning("The loop is partly outside the plotting region. Loop is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  loop.rescale <- RESCALE(loop)#
		  		              panel.3dscatter(x = loop.rescale$X, y = loop.rescale$Y, z = loop.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="black", lty="dashed", lwd=2, ...)#
							}#
						}	  	#
						# ---------------------------------------------------------------------#
						# 6b. Raw data points scatter plot	  #
					  		if (points$show == TRUE) {#
	  			              x2 <- xlim.scaled[1] + diff(xlim.scaled) * (x.points - xlim[1]) / diff(xlim)#
							  if (points$jitter > 0) x2 <- x2 + rnorm(length(x2), 0, points$jitter)#
	  			              y2 <- ylim.scaled[1] + diff(ylim.scaled) * (y.points - ylim[1]) / diff(ylim)#
							  if (points$jitter > 0) y2 <- y2 + rnorm(length(y2), 0, points$jitter)#
							  z2 <- zlim.scaled[1] + diff(zlim.scaled) * (z.points - zlim[1]) / diff(zlim)#
	  			              panel.3dscatter(x = x2, y = y2, z = z2, xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=20, col=points$color, cex=points$cex, ...)#
							  # plot outliers#
							  if (points$out.mark==TRUE) {#
	  			              	panel.3dscatter(x = x2[fit$outliers], y = y2[fit$outliers], z = z2[fit$outliers], xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=4, col="red", cex=points$cex, ...)#
							  }#
					  		}	#
					# ---------------------------------------------------------------------#
					# 7. plot contour lines:#
						if (contour$show == TRUE) {#
							cs <- ggplot(new2, aes_string(x="x", y="y", fill="z", z="z")) + stat_contour(bins=ifelse(length(pal)>1, length(pal)+1, 8))#
							cLines <- ggplot_build(cs)#
							C0 <- cLines$data[[1]][, c("x", "y", "level", "group")]#
							colnames(C0) <- c("X", "Y", "Z", "group")#
							for (cL in C0$group) {#
							  C1 <- RESCALE(C0[C0$group==cL, c("X", "Y", "Z")])#
				             panel.3dscatter(x = C1$X, y = C1$Y, z = C1$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                             xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=contour$color, lty="solid", lwd=1, ...)#
							}#
							# highlight specific contour lines?#
							if (length(contour$highlight) > 0) {#
								C2 <- C0[C0$Z %in% f0(unique(C0$Z), contour$highlight), ]#
								for (cL in C2$group) {#
								  C3 <- RESCALE(C2[C2$group==cL, c("X", "Y", "Z")])#
					              panel.3dscatter(x = C3$X, y = C3$Y, z = C3$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
					                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
												  type="l", col.line=contour$color, lty="solid", lwd=2, ...)#
								}#
							}#
						}#
				}#
				# local function: compute the surface line, defined by a line on the X-Y plane (p0 = intercept, p1=slope)#
				getIntersect2 <- function(p0, p1, Z=NULL) {#
					X <- seq(min(xlim), max(xlim), length.out=grid*2)#
					Y <- p0 + p1*X#
					n <- data.frame(X, Y)#
					n2 <- add.variables(z~X+Y, n)#
					n2$Z <- b0 + colSums(c(x, y, x2, y2, xy)*t(n2[, c(1:5)]))#
					if (!is.null(Z)) n2$Z <- Z#
					return(n2[, c("X", "Y", "Z")])#
				}#
				axesList <- list()#
				if ("LOC" %in% axes) {axesList[["LOC"]]  <- list(p0=0, p1=1, lty="solid", col="grey")}#
				if ("LOIC" %in% axes) {axesList[["LOIC"]] <- list(p0=0, p1=-1, lty="dotted", col="grey")}#
				if ("PA1" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA1")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA1"]] <- list(p0=SP2$p10, p1=SP2$p11, lty="solid", col="black")#
						} else {#
							axesList[["PA1"]] <- list(p0=SP$p10, p1=SP$p11, lty="solid", col="black")#
						}					#
				}#
				if ("PA2" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA2")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA2"]] <- list(p0=SP2$p20, p1=SP2$p21, lty="dotted", col="black")#
					} else {#
						axesList[["PA2"]] <- list(p0=SP$p20, p1=SP$p21, lty="dotted", col="black")	#
					}#
				}			#
				# Define color range: Relative to surface min/max, or relative to box (zlim)?#
				if (pal.range == "box") {#
					at <- seq(zlim[1], zlim[2], length.out=length(pal)-1)#
				} else if (pal.range == "surface") {#
					at <- seq(min(new2$z), max(new2$z), length.out=length(pal)-1)#
				}#
			if (points$show == FALSE) {#
				p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation, #
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2, ...)#
				#p1#
			} else {#
				p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation,#
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2,#
					x.points=xpoints, y.points=ypoints, z.points=zpoints, ...)#
			}#
	}  # of type == "3d"#
	## ======================================================================#
	## Contour plot#
	## ======================================================================#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			# Define color range: Relative to surface min/max, or relative to box (zlim)?#
			if (pal.range == "box") {#
				limits <- c(zlim[1], zlim[2])#
			} else if (pal.range == "surface") {#
				limits <- c(min(new2$z), max(new2$z))#
			}#
			p1 <- ggplot(new2, aes_string(x="x", y="y", z="z")) + geom_tile(aes_string(fill="z")) + scale_fill_gradientn(zlab, colours=pal, limits=limits) + theme_bw() + theme(aspect.ratio=1) + xlab(xlab) + ylab(ylab)#
			if (legend==FALSE) {#
				p1 <- p1 + guides(fill=FALSE)#
			}#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# highlight specific contour lines?#
			if (length(contour$highlight) > 0) {#
				cLines <- ggplot_build(p1)#
				C0 <- cLines$data[[2]][, c("x", "y", "level", "group")]#
#
				# Find closest values in contours#
				C1 <- C0[C0$level %in% f0(unique(C0$level), contour$highlight), ]#
				p1 <- p1 + geom_path(data=C1, aes_string(x="x", y="y", group="group", z="level"), size=1.1)#
			}#
			# (in)congruence lines#
			if ("LOC" %in% axes) {#
				p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey")#
			}#
			if ("LOIC" %in% axes) {#
				p1 <- p1 + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			}#
			if (("PA1" %in% axes) & !any(is.na(SP[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=data.frame(SP[c("p10", "p11")]), aes_string(intercept="p10", slope="p11"))#
			}#
			if (("PA2" %in% axes) & !any(is.na(SP[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=data.frame(SP[c("p20", "p21")]), aes_string(intercept="p20", slope="p21"), linetype="dotted")#
			}#
			if (param==TRUE & !any(is.na(SP[c("X0", "Y0")])) & !model %in% c("RR", "sqdiff", "SSD", "SRSD", "SRR", "SRRR")) {#
				p1 <- p1 + annotate("point", x=SP$X0, y=SP$Y0, z=max(new2$z))#
			}#
			if (points$show == TRUE) {#
				if (points$out.mark==FALSE) {#
					p1 <- p1 + annotate("point", x=xpoints, y=ypoints, color=points$color, size=3*points$cex)#
				}#
				if (points$out.mark==TRUE) {#
					colvec <- rep(points$color, nrow(fit$data.original))#
					colvec[fit$outliers] <- "red"#
					shapevec <- rep(19, nrow(fit$data.original))#
					shapevec[fit$outliers] <- 4#
					p1 <- p1 + annotate("point", x=fit$data.original[, fit$IV1], y=fit$data.original[, fit$IV2], color=colvec, size=3*points$cex, shape=shapevec)#
				}#
			}#
			if (hull==TRUE & !is.null(points$data)) {#
				p1 <- p1 + annotate("path", x=bag$X, y=bag$Y, linetype="dashed", color="grey10")#
				p1 <- p1 + annotate("path", x=loop$X, y=loop$Y, linetype="dotted", color="grey10")#
			}#
			# plot CI of SP#
			if (param==TRUE & SP.CI==TRUE & !is.null(fit)) {#
				PAR <- getPar(fit, "coef", model=model)#
				p1 <- p1 + annotate("errorbar", x=SP$X0, y=SP$Y0, ymin=PAR[PAR$label=="Y0", "ci.lower"], ymax=PAR[PAR$label=="Y0", "ci.upper"], z=max(new2$z), width=.3)#
				p1 <- p1 + annotate("errorbarh", x=SP$X0, y=SP$Y0, xmin=PAR[PAR$label=="X0", "ci.lower"], xmax=PAR[PAR$label=="X0", "ci.upper"], z=max(new2$z), height=.3)#
			}#
		}#
	}#
	return(p1)#
}#
#' @S3method plot RSA#
#
# Purpose: Extract the model parameters, xlim, xlab, etc. from the fitted object and give it to the plotRSA function#
plot.RSA <- function(x, ...) {#
	fit <- x#
	extras <- match.call(expand.dots = FALSE)$...#
	if (is.null(extras)) extras <- list()#
	if (is.null(extras$model)) extras$model <- "full"#
	C <- coef(fit$models[[extras$model]])#
	if (fit$models[[extras$model]]@Options$estimator != "DWLS") {#
		extras$b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), 0, C[paste0(fit$DV, "~1")]))#
	} else {			#
		# the threshold is the negative of the intercept ...#
		extras$b0 <- -as.numeric(ifelse(is.na(C[paste0(fit$DV, "|t1")]), 0, C[paste0(fit$DV, "|t1")]))#
	}#
	extras$x <- as.numeric(ifelse(is.na(C["b1"]), 0, C["b1"]))#
	extras$y <- as.numeric(ifelse(is.na(C["b2"]), 0, C["b2"]))#
	extras$x2 <- as.numeric(ifelse(is.na(C["b3"]), 0, C["b3"]))#
	extras$y2 <- as.numeric(ifelse(is.na(C["b5"]), 0, C["b5"]))#
	extras$xy <- as.numeric(ifelse(is.na(C["b4"]), 0, C["b4"]))#
	extras$w <- as.numeric(ifelse(is.na(C["b6"]), 0, C["b6"]))#
	extras$wx <- as.numeric(ifelse(is.na(C["b7"]), 0, C["b7"]))#
	extras$wy <- as.numeric(ifelse(is.na(C["b8"]), 0, C["b8"]))#
	# cubic parameters#
	extras$x3 <- as.numeric(ifelse(is.na(C["b9"]), 0, C["b9"]))#
	extras$xy2 <- as.numeric(ifelse(is.na(C["b10"]), 0, C["b10"]))#
	extras$x2y <- as.numeric(ifelse(is.na(C["b11"]), 0, C["b11"]))#
	extras$y3 <- as.numeric(ifelse(is.na(C["b12"]), 0, C["b12"]))#
#
	if (is.null(extras$xlim)) {#
		extras$xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
		# expand range by 20% at each end#
		extras$xlim[1] <- extras$xlim[1]*ifelse(extras$xlim[1]<0, 1.1, 0.9)#
		extras$xlim[2] <- extras$xlim[2]*ifelse(extras$xlim[2]<0, 0.9, 1.1)#
	}#
	if (is.null(extras$ylim)) {#
		extras$ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
		extras$ylim[1] <- extras$ylim[1]*ifelse(extras$ylim[1]<0, 1.1, 0.9)#
		extras$ylim[2] <- extras$ylim[2]*ifelse(extras$ylim[2]<0, 0.9, 1.1)#
	}#
	# for the correct visual diagonal: same range for X and Y#
	extras$xlim[1] <- extras$ylim[1] <- min(extras$xlim[1], extras$ylim[1])#
	extras$xlim[2] <- extras$ylim[2] <- max(extras$xlim[2], extras$ylim[2])#
	if (is.null(extras$xlab)) extras$xlab <- fit$IV1#
	if (is.null(extras$ylab)) extras$ylab <- fit$IV2#
	if (is.null(extras$zlab)) extras$zlab <- fit$DV#
	if (is.null(extras$points)) {#
		extras$points <- list(show=TRUE, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE)#
	}#
	extras$points$data <- fit$data[, c(fit$IV1, fit$IV2, fit$DV, colnames(fit$data)[which(!colnames(fit$data) %in% c(fit$IV1, fit$IV2, fit$DV))])]#
	extras$fit <- fit#
	do.call(plotRSA, as.list(extras))#
}#
#plot(r1, type="3d", points=list(show=TRUE, cex=2))#
#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, points=list(data=data.frame(x=-1:3, y=-1:3, z=0), show=TRUE))#
#
#plot(r1)#
#plot(r1, points=list(show=TRUE))#
#plotRSA(x=.05, x2=.1, xy=.20, type="3", gridsize=21)#
#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="3d", points=list(show=TRUE), rotation=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, type="3d")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, legend=FALSE, type="3d")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, legend=FALSE, type="c")#
#
#RSA.ST(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102)#
## Minimal example#
#x <- y <- z <- c(1,2,3)#
#df <- data.frame(x, y, z)#
#wireframe(z ~ x*y, df,  scales = list(arrows = FALSE, col = "black", font = 1, tck = c(1, 1, 1), distance =c(1, 1, 1)))#
##
##
#xyplot(z ~ x, df,  scales = list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck), par.settings=list(axis.components=list(left=list(pad1=2))))
plot(r1, surface="smooth", zlim=c(-1.5, 1.5), lambda=4)
plotRSA(surface="smooth", zlim=c(-1.5, 1.5), lambda=4, points=list(show=TRUE, data=dat1[, c("status_m", "status_w", "ras_m")]))
r1 <- RSA(ras_m ~ status_m*status_w, dat1)#
plot(r1)
plot(r1, surface="smooth", zlim=c(-1.5, 1.5), lambda=4)
plot(r1, zlim=c(-1.5, 1.5))
plot(r1, surface="smooth", zlim=c(-1.5, 1.5), lambda=4)
plotRSA(surface="smooth", zlim=c(-1.5, 1.5), lambda=4, points=list(show=TRUE, data=dat1[, c("status_m", "status_w", "ras_m")]))
plot(r1, zlim=c(-1.5, 1.5), xlim=c(-3, 3), ylim=c(-3, 3))
plot(r1, zlim=c(-1.5, 1.5), xlim=c(-3, 3), ylim=c(-3, 3))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
plot.RSA <- function(x, ...) {#
	fit <- x#
	extras <- match.call(expand.dots = FALSE)$...#
	if (is.null(extras)) extras <- list()#
	if (is.null(extras$model)) extras$model <- "full"#
	C <- coef(fit$models[[extras$model]])#
	if (fit$models[[extras$model]]@Options$estimator != "DWLS") {#
		extras$b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), 0, C[paste0(fit$DV, "~1")]))#
	} else {			#
		# the threshold is the negative of the intercept ...#
		extras$b0 <- -as.numeric(ifelse(is.na(C[paste0(fit$DV, "|t1")]), 0, C[paste0(fit$DV, "|t1")]))#
	}#
	extras$x <- as.numeric(ifelse(is.na(C["b1"]), 0, C["b1"]))#
	extras$y <- as.numeric(ifelse(is.na(C["b2"]), 0, C["b2"]))#
	extras$x2 <- as.numeric(ifelse(is.na(C["b3"]), 0, C["b3"]))#
	extras$y2 <- as.numeric(ifelse(is.na(C["b5"]), 0, C["b5"]))#
	extras$xy <- as.numeric(ifelse(is.na(C["b4"]), 0, C["b4"]))#
	extras$w <- as.numeric(ifelse(is.na(C["b6"]), 0, C["b6"]))#
	extras$wx <- as.numeric(ifelse(is.na(C["b7"]), 0, C["b7"]))#
	extras$wy <- as.numeric(ifelse(is.na(C["b8"]), 0, C["b8"]))#
	# cubic parameters#
	extras$x3 <- as.numeric(ifelse(is.na(C["b9"]), 0, C["b9"]))#
	extras$xy2 <- as.numeric(ifelse(is.na(C["b10"]), 0, C["b10"]))#
	extras$x2y <- as.numeric(ifelse(is.na(C["b11"]), 0, C["b11"]))#
	extras$y3 <- as.numeric(ifelse(is.na(C["b12"]), 0, C["b12"]))#
#
	if (is.null(extras$xlim)) {#
		extras$xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
		# expand range by 20% at each end#
		extras$xlim[1] <- extras$xlim[1]*ifelse(extras$xlim[1]<0, 1.1, 0.9)#
		extras$xlim[2] <- extras$xlim[2]*ifelse(extras$xlim[2]<0, 0.9, 1.1)#
		extras$xlim[1] <- extras$ylim[1] <- min(extras$xlim[1], extras$ylim[1])#
	}#
	if (is.null(extras$ylim)) {#
		extras$ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
		extras$ylim[1] <- extras$ylim[1]*ifelse(extras$ylim[1]<0, 1.1, 0.9)#
		extras$ylim[2] <- extras$ylim[2]*ifelse(extras$ylim[2]<0, 0.9, 1.1)#
		extras$xlim[2] <- extras$ylim[2] <- max(extras$xlim[2], extras$ylim[2])#
	}#
	if (is.null(extras$xlab)) extras$xlab <- fit$IV1#
	if (is.null(extras$ylab)) extras$ylab <- fit$IV2#
	if (is.null(extras$zlab)) extras$zlab <- fit$DV#
	if (is.null(extras$points)) {#
		extras$points <- list(show=TRUE, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE)#
	}#
	extras$points$data <- fit$data[, c(fit$IV1, fit$IV2, fit$DV, colnames(fit$data)[which(!colnames(fit$data) %in% c(fit$IV1, fit$IV2, fit$DV))])]#
	extras$fit <- fit#
	do.call(plotRSA, as.list(extras))#
}
plot(r1, zlim=c(-1.5, 1.5), xlim=c(-3, 3), ylim=c(-3, 3))
plot(r1, surface="smooth", zlim=c(-1.5, 1.5), xlim=c(-3, 3), ylim=c(-3, 3), lambda=4)
plotRSA(surface="smooth", zlim=c(-1.5, 1.5), xlim=c(-3, 3), ylim=c(-3, 3), lambda=4, points=list(show=TRUE, data=dat1[, c("status_m", "status_w", "ras_m")]))
plotRSA(surface="smooth", zlim=c(-1.5, 1.5), xlim=c(-3, 3), ylim=c(-3, 3), lambda=6, points=list(show=TRUE, data=dat1[, c("status_m", "status_w", "ras_m")]))
plotRSA(surface="smooth", zlim=c(-1.5, 1.5), xlim=c(-3, 3), ylim=c(-3, 3), lambda=10, points=list(show=TRUE, data=dat1[, c("status_m", "status_w", "ras_m")]))
plotRSA(surface="smooth", zlim=c(-1.5, 1.5), xlim=c(-3, 3), ylim=c(-3, 3), lambda=6, points=list(show=TRUE, data=dat1[, c("status_m", "status_w", "ras_m")]))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters#
#'#
#' @details#
#' Each plot type has its distinctive advantages. The two-dimensional contour plot gives a clear view of the position of the principal axes and the stationary point. The 3d plot gives a three dimensional impression of the surface, allows overplotting of the original data points (in case an RSA object is provided), and allows the interactive adjustment of regression weights in the \code{\link{demoRSA}} function. The interactive plot allows rotating and exploring a three-dimensional surface with the mouse (nice for demonstration purposes).#
#' If you want to export publication-ready plots, it is recommended to export it with following commands:#
#' \code{p1 <- plot(r1, bw=TRUE)#
#' trellis.device(device="cairo_pdf", filename="RSA_plot.pdf")#
#' print(p1)#
#' dev.off()}#
#'#
#' @aliases plotRSA#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param y3 Y^3 coefficient#
#' @param x3 X^3 coefficient#
#' @param xy2 XY^2 coefficient#
#' @param x2y X^2Y coefficient#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param xlab Label for x axis#
#' @param ylab Label for y axis#
#' @param zlab Label for z axis#
#' @param surface Method for the calculation of the surface z values. "predict" takes the predicted values from the model, "smooth" uses a thin plate smoother (function \code{Tps} from the \code{fields} package) of the raw data#
#' @param lambda lambda parameter for the smoother. Default (NULL) means that it is estimated by the smoother function. Small lambdas around 1 lead to rugged surfaces, big lambdas to very smooth surfaces.#
#' @param rotation Rotation of the 3d surface plot (when type == "3d")#
#' @param label.rotation Rotation of the axis labls (when type == "3d")#
#' @param gridsize Number of grid nodes in each dimension#
#' @param bw Print surface in black and white instead of colors?#
#' @param legend Print color legend for z values?#
#' @param cex Font size factor for axes labels#
#' @param type \code{3d} for 3d surface plot, \code{contour} for 2d contour plot, "interactive" for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient#
#' @param points A list of parameters which define the appearance of the raw scatter points: #
#'	\itemize{#
#'		\item{data: Data frame which contains the coordinates of the raw data points. FIrst column = x, second = y, third = z. This data frame is automatically generated when the plot is based on a fitted RSA-object}#
#'		\item{show = TRUE: Should the original data points be overplotted?}#
#' 		\item{value="raw": Plot the original z value, "predicted": plot the predicted z value}#
#'		\item{jitter = 0: Amount of jitter for the raw data points. For z values, a value of 0.005 is reasonable}#
#'		\item{cex = .5: multiplication factor for point size}#
#' 		\item{out.mark = FALSE: If set to TRUE, outliers according to Bollen & Jackman (1980) are printed as red X symbols. This option works regardless of whether the RSA function has set out.rm to TRUE or FALSE: #
#'			\itemize{#
#'				\item{If out.rm == TRUE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is removed from the model and *not plotted* in plotRSA.}#
#'				\item{If out.rm == TRUE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is removed from the model but plotted and marked in plotRSA.}#
#'				\item{If out.rm == FALSE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is not removed from the model and plotted as a normal point in plotRSA (but not marked as outlier).}#
#'				\item{If out.rm == FALSE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is not removed from the model, but plotted and marked in plotRSA.}#
#'				\item{Example syntax: \code{plotRSA(r1, points=list(show=TRUE, out.mark=TRUE))}}#
#'		}}#
#'	}#
#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param demo Do not change that parameter (internal use only)#
#' @param fit Do not change that parameter (internal use only)#
#' @param param Should the surface parameters a1 to a4 be shown on the plot? In case of a 3d plot a1 to a4 are printed on the upper left side; in case of a contour plot the principal axes are plotted.#
#' @param axes A vector of strings specifying the axes that should be plotted. Can be any combination of c("LOC", "LOIC", "PA1", "PA2"). LOC = line of congruence, LOIC = line of incongruence, PA1 = first principal axis, PA2 = second principal axis#
#' @param project Should the LOC, LOIC, etc. (as defined in parameter \code{axes}) be also plotted as a projection on the bottom of the cube?#
#' @param maxlines Should the maximum lines be plotted? (red: maximum X for a given Y, blue: maximum Y for a given X). Works only in type="3d"#
#' @param link Link function to transform the z axes. Implemented are "identity" (no transformation; default), "probit", and "logit"#
#' @param border Should a thicker border around the surface be plotted? Sometimes this border leaves the surrounding box, which does not look good. In this case the border can be suppressed by setting \code{border=FALSE}.#
#' @param contour A list defining the appearance of contour lines (aka. height lines). show=TRUE: Should the contour lines be plotted on the 3d wireframe plot? (Parameter only relevant for \code{type="3d"}). color = "grey40": Color of the contour lines. highlight = c(): A vector of heights which should be highlighted (i.e., printed in bold). Be careful: the highlighted line is not necessarily exactly at the specified height; instead the nearest height line is selected.#
#' @param hull Plot a bag plot on the surface (This is a bivariate extension of the boxplot. 50% of points are in the inner bag, 50% in the outer region). See Rousseeuw, Ruts, & Tukey (1999).#
#' @param SP.CI Plot the CI of the stationary point (only relevant for \code{type="contour"})#
#' @param distance A vector of three values defining the distance of labels to the axes#
#' @param tck A vector of three values defining the position of labels to the axes (see ?wireframe)#
#' @param pal A palette for shading#
#' @param pal.range Should the color range be scaled to the box (\code{pal.range = "box"}, default), or to the min and max of the surface (\code{pal.range = "surface"})? If set to "box", different surface plots can be compared along their color, as long as the zlim is the same for both.#
#' @param pad Pad controls the margin around the figure (positive numbers: larger margin, negative numbers: smaller margin)#
#'#' @param ... Additional parameters passed to the plotting function (e.g., sub="Title"). A useful title might be the R squared of the plotted model: sub = as.expression(bquote(R^2==.(round(getPar(x, "r2", model="full"), 3))))#
#'#
#' @references#
#' Rousseeuw, P. J., Ruts, I., & Tukey, J. W. (1999). The Bagplot: A Bivariate Boxplot. The American Statistician, 53(4), 382-387. doi:10.1080/00031305.1999.10474494#
#' @seealso \code{\link{demoRSA}}, \code{\link{RSA}}#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' # Default: 3d plot:#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628)#
#' # Contour plot:#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="c")#
#' # Interactive plot (try the mouse!):#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="i")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df, models=c("sqdiff", "full", "IA"))#
#' plot(r1)	# default: model = "full"#
#' plot(r1, model="sqdiff", points=list(show=TRUE, value="predicted"))#
#b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-2, 2); ylim=c(-2, 2); rotation=list(x=-45, y=45, z=35); legend=TRUE; cex=1.2; type="3d"; points=TRUE; demo=FALSE; model="full"; #
#
#b0=-9; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=1; wy=-1;  zlim=NULL; xlim=c(-2, 2); ylim=c(-2, 2); rotation=list(x=-45, y=45, z=35); legend=TRUE; cex=1.2; type="3d"; points=TRUE; demo=FALSE; model="full"; fit=NULL; link="identity"; param=TRUE; gridsize=21;bw=FALSE; pal=NULL; axes=c("LOC", "LOIC", "PA1", "PA2"); distance=c(1, 1, 1); tck=c(1, 1, 1); xlab="X"; ylab="Y"; zlab="Z"; border=TRUE;#
#
## old rotation#
# rotation=list(x=-45, y=45, z=35), label.rotation=list(x=45, y=-25, z=94)#
# distance=c(1, 1, 1), tck=c(1, 1, 1)#
#
plotRSA <- function(x=0, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, x3=0, xy2=0, x2y=0, y3=0, b0=0, type="3d", model="full", #
	xlim=NULL, ylim=NULL, zlim=NULL, xlab=NULL, ylab=NULL, zlab=NULL, #
	surface="predict", lambda=NULL, #
	rotation=list(x=-63, y=32, z=15), label.rotation=list(x=19, y=-40, z=92), #
	gridsize=21, bw=FALSE, legend=TRUE, param=TRUE, #
	axes=c("LOC", "LOIC", "PA1", "PA2"), project=FALSE, maxlines=FALSE,#
	cex=1.2,#
	points = list(data=NULL, show=NA, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE),#
	demo=FALSE, fit=NULL, link="identity", #
	tck=c(1.5, 1.5, 1.5), distance=c(1.3, 1.3, 1.4), border=TRUE, #
	contour = list(show=FALSE, color="grey40", highlight = c()),#
	hull=FALSE, SP.CI=FALSE, #
	pal=NULL, pal.range="box", #
	pad=0, ...) {#
	if (!identical(xlim, ylim)) {warning("Axes dimensions are not equal. The visual diagonal is *not* the line of numerical congruence! Consider choosing identical values for xlim and ylim.")}#
	# define the defaults#
	if (is.null(points$show)) points$show <- TRUE#
	if (is.na(points$show)) {#
		if (is.null(points$data)) {#
			points$show <- FALSE	#
		} else {#
			points$show <- TRUE#
		}#
	}#
	if (is.null(points$value)) points$value <- "raw"#
	if (is.null(points$color)) points$color <- "black"#
	if (is.null(points$jitter)) points$jitter <- 0#
	if (is.null(points$cex)) points$cex <- 0.5#
	if (is.null(points$out.mark)) points$out.mark <- FALSE#
	if (points$show==TRUE & is.null(points$data)) {#
		warning("You must provide a data frame with the coordinates of the raw data points (points = list(show = TRUE, data = ???)). Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (is.null(contour$show)) contour$show <- TRUE#
	if (is.null(contour$color)) contour$color <- "grey40"#
	if (is.null(contour$highlight)) contour$highlight <- c()#
	type <- match.arg(type, c("interactive", "3d", "contour"))#
	surface <- match.arg(surface, c("predict", "smooth"))#
	points[["value"]] <- match.arg(points[["value"]], c("raw", "predicted"))#
#
	if (demo == FALSE) {#
			if (is.null(xlab)) {#
				if (!is.null(points$data)) {#
					xlab <- colnames(points$data)[1]#
				} else {#
					xlab <- "X"#
				}#
			}#
			if (is.null(ylab)) {#
				if (!is.null(points$data)) {#
					ylab <- colnames(points$data)[2]#
				} else {#
					ylab <- "Y"#
				}#
			}#
			if (is.null(zlab)) {#
				if (!is.null(points$data)) {#
					zlab <- colnames(points$data)[3]#
				} else {#
					zlab <- "Z"#
				}#
			}#
			if (is.null(xlim)) {xlim <- c(-2.1, 2.1)}#
			if (is.null(ylim)) {ylim <- c(-2.1, 2.1)}#
	}#
	if (is.null(points$data) & surface == "smooth") {#
		warning("Smoothing only works if data points are provided (points=list(data=???))! Reverting to surface = 'predict'")#
		surface <- "predict"#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy,x3, xy2, x2y, y3)#
	if (!model %in% c("absunc", "absdiff")) {#
		if (!is.null(fit) & model != "cubic" & model != "null") {#
			SP <- RSA.ST(fit, model=model)#
		} else {#
			SP <- RSA.ST(x=x, y=y, xy=xy, x2=x2, y2=y2)#
		}#
		SP.text <- paste0("a", 1:4, ": ", f2(SP$SP$estimate, 2), sig2star(SP$SP$p.value), collapse="    ")#
	} else {#
		SP <- NULL#
		param <- FALSE#
		SP.text <- ""#
	}#
	# build data set#
	grid <- gridsize#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	if (surface == "predict") {#
		new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11, 15:18)]))#
	}#
	if (surface == "smooth") {#
		library(fields)#
		tpsfit <- Tps(points$data[, 1:2], points$data[, 3], scale.type="unscaled", lambda=lambda)#
		new2$z <- predict(tpsfit, new[, c("x", "y")])#
		param <- FALSE#
		axes <- ""#
	}#
	# impose link functions#
	logit <- function (x) {log(x/(1-x))}#
	invlogit <- function (x) {1/(1+exp(-x))}#
	link <- match.arg(link, c("identity", "logit", "probit"))#
	if (link == "probit") {#
		z.trans <- 1.7 * new2$z#
		new2$z <- invlogit(z.trans)#
	}#
	if (link == "logit") {#
		new2$z <- invlogit(new2$z)#
	}#
#
	# determine zlim#
	if (!is.null(points$data) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(points$data[, 3], na.rm=TRUE)), max(max(new2$z, na.rm=TRUE), max(points$data[, 3], na.rm=TRUE)))#
	} else {#
		if (is.null(zlim)) zlim <- c(min(new2$z), max(new2$z))#
	}#
	zlim.final <- zlim#
	## Plots#
	if (bw == FALSE) {#
		# RdYlGn palette#
		if (is.null(pal)) {#
			pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
		}#
		gridCol <- ifelse(contour$show == TRUE, "grey60", "grey30")#
	} else {#
		if (is.null(pal)) {#
			pal <- colorRampPalette(c("#FFFFFF", "#AAAAAA", "#030303"), bias=2)(11)#
		}#
		gridCol <- ifelse(contour$show == TRUE, "grey30", "grey30")#
	}#
	if (length(pal) < 2) {legend <- FALSE}#
	# ---------------------------------------------------------------------#
	# Calculate positions of raw points#
#
	if (points$out.mark == TRUE & is.null(fit)) {#
		warning("Outliers can only be marked if an RSA-object is provided. Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (points$show == TRUE) {#
		if (points$out.mark == FALSE) {#
			data.used <- points$data#
		}#
		if (points$out.mark == TRUE & !is.null(fit)) {#
			data.used <- fit$data.original#
		}#
		if (points$value == "raw") {#
			zpoints <- as.vector(data.used[, 3])#
		} else if (points$value == "predicted") {#
			N <- colnames(data.used)#
			data.used2 <- add.variables(formula(paste0(N[3], " ~ ", N[1], "*", N[2])), data.used)#
			# calculate predicted values#
			zpoints <- b0 + colSums(C*t(data.used2[, c(#
				N[1],#
				N[2],#
				paste0(N[1], "2"),#
				paste0(N[2], "2"),#
				paste0(N[1], "_", N[2]),#
				"W",#
				paste0("W_", N[1]),#
				paste0("W_", N[2]),#
				paste0(N[1], "3"),#
				paste0(N[1], "_", N[2], "2"),#
				paste0(N[1], "2", "_", N[2]),#
				paste0(N[2], "3")#
			)]))#
			zpoints <- as.vector(zpoints)#
		}#
#
		xpoints <- as.vector(data.used[, 1])#
		ypoints <- as.vector(data.used[, 2])#
	}#
	# ---------------------------------------------------------------------#
	#  calculate bag plot: bag = outer, loop = inner#
	if (hull==TRUE) {#
		library(aplpack)#
		BAG <- compute.bagplot(xpoints, ypoints)#
		# close the polygon#
		h1 <- rbind(BAG$hull.bag, BAG$hull.bag[1, ])#
		h2 <- rbind(BAG$hull.loop, BAG$hull.loop[1, ])#
#
		# approx: interpolate the points of the bag (in order to get a more smooth fitting line on the z-axis)#
		minDist <- min(diff(xlim)/gridsize, diff(ylim)/gridsize)/2#
#
		h1 <- interpolatePolyon(h1[, 1], h1[, 2], minDist=minDist)	#
		h2 <- interpolatePolyon(h2[, 1], h2[, 2], minDist=minDist)	#
		# calculate predicted values#
		bagpoints <- add.variables(z~x+y, data.frame(x=h1$x, y=h1$y))#
		bagpoints$z <- b0 + colSums(C*t(bagpoints[, c(1:5, 9:11, 15:18)]))#
		bag <- data.frame(X  = bagpoints$x, Y  = bagpoints$y, Z = bagpoints$z)#
		looppoints <- add.variables(z~x+y, data.frame(x=h2$x, y=h2$y))#
		looppoints$z <- b0 + colSums(C*t(looppoints[, c(1:5, 9:11, 15:18)]))#
		loop <- data.frame(X  = looppoints$x, Y  = looppoints$y, Z = looppoints$z)			#
	}#
	## ======================================================================#
	## Interactive plot#
	## ======================================================================#
	if (type == "interactive") {#
		library(rgl)#
		P <- list(x=seq(xlim[1], xlim[2], length.out=grid), y=seq(ylim[1], ylim[2], length.out=grid))#
		DV2 <- matrix(new2$z, nrow=grid, ncol=grid, byrow=FALSE)#
		R <- range(DV2)#
		col2 <- as.character(cut(1:(R[2] - R[1] + 1), breaks=length(pal), labels=pal))#
		open3d()#
		rgl.viewpoint(-30, -90)#
		rgl.light(theta = 0, phi = 90, viewpoint.rel = TRUE, ambient = "#FF0000", diffuse = "#FFFFFF", specular = "#FFFFFF")#
		persp3d(P$x, P$y, DV2, xlab = xlab, ylab = ylab, zlab = zlab, color=col2[DV2 - R[1] + 1])#
#
		if (contour$show == TRUE) {#
		    contours <- contourLines(P, z=DV2)#
		     for (i in 1:length(contours)) {#
				 with(contours[[i]], lines3d(x, y, level, col=contour$color))#
			 }#
		 }#
		if (points$show == TRUE) {#
			if (points$out.mark == FALSE) {#
				points3d(data.frame(xpoints, ypoints, zpoints), col=points$color)#
			}#
			if (points$out.mark == TRUE & !is.null(fit)) {#
				colvec <- rep(points$color, nrow(fit$data.original))#
				colvec[fit$outliers] <- "red"#
				points3d(fit$data.original[, c(fit$IV1, fit$IV2, fit$DV)], col=colvec)#
				text3d(fit$data.original[fit$outliers, c(fit$IV1, fit$IV2, fit$DV)], col="red", texts="X")#
			} else {#
				warning("Please provide an RSA-object to mark outliers.")#
			}#
		}#
		p1 <- NULL	# no plot object is returned	#
	}	#
	## ======================================================================#
	## Wireframe plot#
	## ======================================================================#
	if (type == "3d") {#
			mypanel2 <- function(x, y, z, xlim, ylim, zlim, xlim.scaled, ylim.scaled, zlim.scaled, axes, x.points=NULL, y.points=NULL, z.points=NULL, SPs="", ...) {#
			   # rescale absolute x, y, and z values so that they fit into the box#
			   RESCALE <- function(n) {#
				  X2 <- xlim.scaled[1] + diff(xlim.scaled) * (n$X - xlim[1]) / diff(xlim)#
	              Y2 <- ylim.scaled[1] + diff(ylim.scaled) * (n$Y - ylim[1]) / diff(ylim)#
	              Z2 <- zlim.scaled[1] + diff(zlim.scaled) * (n$Z - zlim[1]) / diff(zlim)#
				  df <- data.frame(X=X2, Y=Y2, Z=Z2)#
				  df <- df[df$X >= min(xlim.scaled) & df$X <= max(xlim.scaled) & df$Y >= min(ylim.scaled) & df$Y <= max(ylim.scaled) &  df$Z >= min(zlim.scaled) & df$Z <= max(zlim.scaled), ]#
				  return(df)#
			   }#
			# ---------------------------------------------------------------------#
			# 1. Projection on bottom of cube#
			  if (project==TRUE) {#
				  for (a in axes) {#
					  #print(paste("Plotting projection of", names(a)))#
					  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1, Z=zlim.final[1] + .01))#
		              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
				  } #
			  }#
			   # ---------------------------------------------------------------------#
			   # 2. Borders, back part#
					if (border==TRUE) {#
						  # Make boundary of grid a bit thicker#
						  box1 <- new2[new2$y == max(new2$y), ]#
						  box2 <- new2[new2$y == min(new2$y), ]#
						  box3 <- new2[new2$x == max(new2$x), ]#
						  box4 <- new2[new2$x == min(new2$x), ]#
						  box <- rbind(data.frame(box1, side=1), data.frame(box2, side=2), data.frame(box3, side=3), data.frame(box4, side=4))#
			              x.box <- xlim.scaled[1] + diff(xlim.scaled) * (box$x - xlim[1]) / diff(xlim)#
			              y.box <- ylim.scaled[1] + diff(ylim.scaled) * (box$y - ylim[1]) / diff(ylim)#
			              z.box <- zlim.scaled[1] + diff(zlim.scaled) * (box$z - zlim[1]) / diff(zlim)#
						  # plot the back lines of the border#
			              panel.3dscatter(x = x.box[box$side==1], y = y.box[box$side==1], z = z.box[box$side==1], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
						  panel.3dscatter(x = x.box[box$side==3], y = y.box[box$side==3], z = z.box[box$side==3], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
					  }#
					  # ---------------------------------------------------------------------#
					  # 3. the surface#
						  panel.3dwire(x = x, y = y, z = z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                           xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
								   col=gridCol,  lwd=0.3, ...)#
					# ---------------------------------------------------------------------#
					# 4. plot of LOC and LOIC, and other axes#
						  for (a in axes) {#
							  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1))#
				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
						  }   #
  					# ---------------------------------------------------------------------#
  					# 4b. plot of maximum lines#
					if (maxlines == TRUE) {#
						# maximum X for a given Y#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[1]/C[5]), p1=-((2*C[3])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="red", lty="dashed", lwd=2, ...)#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[2]/(2*C[4])), p1=-((C[5])/(2*C[4]))))#
							  #a0 <- RESCALE(getIntersect2(p0=-(C[2]/C[5]), p1=-((2*C[4])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="blue", lty="dashed", lwd=2, ...)#
					}#
					# ---------------------------------------------------------------------#
					# 5. Borders, front part	  #
					   if (border==TRUE) {#
 						  # plot the front boundary lines#
 			              panel.3dscatter(x = x.box[box$side==2], y = y.box[box$side==2], z = z.box[box$side==2], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
						  panel.3dscatter(x = x.box[box$side==4], y = y.box[box$side==4], z = z.box[box$side==4], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
					   }#
						  if (param == TRUE) {#
							  grid.text(SPs, .02, .95, just="left")#
						  }  #
						# ---------------------------------------------------------------------#
						# 6a: The bag plot, if requested#
						if (hull==TRUE) {	#
							# bag (= inner bag)#
							if (any(bag$X < xlim[1] | bag$X > xlim[2] | bag$Y < ylim[1] | bag$Y > ylim[2])) {#
								warning("The bag is partly outside the plotting region. Bag is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  bag.rescale <- RESCALE(bag)#
		  		              panel.3dscatter(x = bag.rescale$X, y = bag.rescale$Y, z = bag.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="grey30", lty="dashed", lwd=2, ...)#
							}#
							# loop (= outer bag)#
							if (any(loop$X < xlim[1] | loop$X > xlim[2] | loop$Y < ylim[1] | loop$Y > ylim[2])) {#
								warning("The loop is partly outside the plotting region. Loop is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  loop.rescale <- RESCALE(loop)#
		  		              panel.3dscatter(x = loop.rescale$X, y = loop.rescale$Y, z = loop.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="black", lty="dashed", lwd=2, ...)#
							}#
						}	  	#
						# ---------------------------------------------------------------------#
						# 6b. Raw data points scatter plot	  #
					  		if (points$show == TRUE) {#
	  			              x2 <- xlim.scaled[1] + diff(xlim.scaled) * (x.points - xlim[1]) / diff(xlim)#
							  if (points$jitter > 0) x2 <- x2 + rnorm(length(x2), 0, points$jitter)#
	  			              y2 <- ylim.scaled[1] + diff(ylim.scaled) * (y.points - ylim[1]) / diff(ylim)#
							  if (points$jitter > 0) y2 <- y2 + rnorm(length(y2), 0, points$jitter)#
							  z2 <- zlim.scaled[1] + diff(zlim.scaled) * (z.points - zlim[1]) / diff(zlim)#
	  			              panel.3dscatter(x = x2, y = y2, z = z2, xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=20, col=points$color, cex=points$cex, ...)#
							  # plot outliers#
							  if (points$out.mark==TRUE) {#
	  			              	panel.3dscatter(x = x2[fit$outliers], y = y2[fit$outliers], z = z2[fit$outliers], xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=4, col="red", cex=points$cex, ...)#
							  }#
					  		}	#
					# ---------------------------------------------------------------------#
					# 7. plot contour lines:#
						if (contour$show == TRUE) {#
							cs <- ggplot(new2, aes_string(x="x", y="y", fill="z", z="z")) + stat_contour(bins=ifelse(length(pal)>1, length(pal)+1, 8))#
							cLines <- ggplot_build(cs)#
							C0 <- cLines$data[[1]][, c("x", "y", "level", "group")]#
							colnames(C0) <- c("X", "Y", "Z", "group")#
							for (cL in C0$group) {#
							  C1 <- RESCALE(C0[C0$group==cL, c("X", "Y", "Z")])#
				             panel.3dscatter(x = C1$X, y = C1$Y, z = C1$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                             xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=contour$color, lty="solid", lwd=1, ...)#
							}#
							# highlight specific contour lines?#
							if (length(contour$highlight) > 0) {#
								C2 <- C0[C0$Z %in% f0(unique(C0$Z), contour$highlight), ]#
								for (cL in C2$group) {#
								  C3 <- RESCALE(C2[C2$group==cL, c("X", "Y", "Z")])#
					              panel.3dscatter(x = C3$X, y = C3$Y, z = C3$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
					                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
												  type="l", col.line=contour$color, lty="solid", lwd=2, ...)#
								}#
							}#
						}#
				}#
				# local function: compute the surface line, defined by a line on the X-Y plane (p0 = intercept, p1=slope)#
				getIntersect2 <- function(p0, p1, Z=NULL) {#
					X <- seq(min(xlim), max(xlim), length.out=grid*2)#
					Y <- p0 + p1*X#
					n <- data.frame(X, Y)#
					n2 <- add.variables(z~X+Y, n)#
					n2$Z <- b0 + colSums(c(x, y, x2, y2, xy)*t(n2[, c(1:5)]))#
					if (!is.null(Z)) n2$Z <- Z#
					return(n2[, c("X", "Y", "Z")])#
				}#
				axesList <- list()#
				if ("LOC" %in% axes) {axesList[["LOC"]]  <- list(p0=0, p1=1, lty="solid", col="grey")}#
				if ("LOIC" %in% axes) {axesList[["LOIC"]] <- list(p0=0, p1=-1, lty="dotted", col="grey")}#
				if ("PA1" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA1")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA1"]] <- list(p0=SP2$p10, p1=SP2$p11, lty="solid", col="black")#
						} else {#
							axesList[["PA1"]] <- list(p0=SP$p10, p1=SP$p11, lty="solid", col="black")#
						}					#
				}#
				if ("PA2" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA2")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA2"]] <- list(p0=SP2$p20, p1=SP2$p21, lty="dotted", col="black")#
					} else {#
						axesList[["PA2"]] <- list(p0=SP$p20, p1=SP$p21, lty="dotted", col="black")	#
					}#
				}			#
				# Define color range: Relative to surface min/max, or relative to box (zlim)?#
				if (pal.range == "box") {#
					at <- seq(zlim[1], zlim[2], length.out=length(pal)-1)#
				} else if (pal.range == "surface") {#
					at <- seq(min(new2$z), max(new2$z), length.out=length(pal)-1)#
				}#
			if (points$show == FALSE) {#
				p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation, #
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2, ...)#
				#p1#
			} else {#
				p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation,#
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2,#
					x.points=xpoints, y.points=ypoints, z.points=zpoints, ...)#
			}#
	}  # of type == "3d"#
	## ======================================================================#
	## Contour plot#
	## ======================================================================#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			# Define color range: Relative to surface min/max, or relative to box (zlim)?#
			if (pal.range == "box") {#
				limits <- c(zlim[1], zlim[2])#
			} else if (pal.range == "surface") {#
				limits <- c(min(new2$z), max(new2$z))#
			}#
			p1 <- ggplot(new2, aes_string(x="x", y="y", z="z")) + geom_tile(aes_string(fill="z")) + scale_fill_gradientn(zlab, colours=pal, limits=limits) + theme_bw() + theme(aspect.ratio=1) + xlab(xlab) + ylab(ylab)#
			if (legend==FALSE) {#
				p1 <- p1 + guides(fill=FALSE)#
			}#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# highlight specific contour lines?#
			if (length(contour$highlight) > 0) {#
				cLines <- ggplot_build(p1)#
				C0 <- cLines$data[[2]][, c("x", "y", "level", "group")]#
#
				# Find closest values in contours#
				C1 <- C0[C0$level %in% f0(unique(C0$level), contour$highlight), ]#
				p1 <- p1 + geom_path(data=C1, aes_string(x="x", y="y", group="group", z="level"), size=1.1)#
			}#
			# (in)congruence lines#
			if ("LOC" %in% axes) {#
				p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey")#
			}#
			if ("LOIC" %in% axes) {#
				p1 <- p1 + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			}#
			if (("PA1" %in% axes) & !any(is.na(SP[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=data.frame(SP[c("p10", "p11")]), aes_string(intercept="p10", slope="p11"))#
			}#
			if (("PA2" %in% axes) & !any(is.na(SP[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=data.frame(SP[c("p20", "p21")]), aes_string(intercept="p20", slope="p21"), linetype="dotted")#
			}#
			if (param==TRUE & !any(is.na(SP[c("X0", "Y0")])) & !model %in% c("RR", "sqdiff", "SSD", "SRSD", "SRR", "SRRR")) {#
				p1 <- p1 + annotate("point", x=SP$X0, y=SP$Y0, z=max(new2$z))#
			}#
			if (points$show == TRUE) {#
				if (points$out.mark==FALSE) {#
					p1 <- p1 + annotate("point", x=xpoints, y=ypoints, color=points$color, size=3*points$cex)#
				}#
				if (points$out.mark==TRUE) {#
					colvec <- rep(points$color, nrow(fit$data.original))#
					colvec[fit$outliers] <- "red"#
					shapevec <- rep(19, nrow(fit$data.original))#
					shapevec[fit$outliers] <- 4#
					p1 <- p1 + annotate("point", x=fit$data.original[, fit$IV1], y=fit$data.original[, fit$IV2], color=colvec, size=3*points$cex, shape=shapevec)#
				}#
			}#
			if (hull==TRUE & !is.null(points$data)) {#
				p1 <- p1 + annotate("path", x=bag$X, y=bag$Y, linetype="dashed", color="grey10")#
				p1 <- p1 + annotate("path", x=loop$X, y=loop$Y, linetype="dotted", color="grey10")#
			}#
			# plot CI of SP#
			if (param==TRUE & SP.CI==TRUE & !is.null(fit)) {#
				PAR <- getPar(fit, "coef", model=model)#
				p1 <- p1 + annotate("errorbar", x=SP$X0, y=SP$Y0, ymin=PAR[PAR$label=="Y0", "ci.lower"], ymax=PAR[PAR$label=="Y0", "ci.upper"], z=max(new2$z), width=.3)#
				p1 <- p1 + annotate("errorbarh", x=SP$X0, y=SP$Y0, xmin=PAR[PAR$label=="X0", "ci.lower"], xmax=PAR[PAR$label=="X0", "ci.upper"], z=max(new2$z), height=.3)#
			}#
		}#
	}#
	return(p1)#
}#
#' @S3method plot RSA#
#
# Purpose: Extract the model parameters, xlim, xlab, etc. from the fitted object and give it to the plotRSA function#
plot.RSA <- function(x, ...) {#
	fit <- x#
	extras <- match.call(expand.dots = FALSE)$...#
	if (is.null(extras)) extras <- list()#
	if (is.null(extras$model)) extras$model <- "full"#
	C <- coef(fit$models[[extras$model]])#
	if (fit$models[[extras$model]]@Options$estimator != "DWLS") {#
		extras$b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), 0, C[paste0(fit$DV, "~1")]))#
	} else {			#
		# the threshold is the negative of the intercept ...#
		extras$b0 <- -as.numeric(ifelse(is.na(C[paste0(fit$DV, "|t1")]), 0, C[paste0(fit$DV, "|t1")]))#
	}#
	extras$x <- as.numeric(ifelse(is.na(C["b1"]), 0, C["b1"]))#
	extras$y <- as.numeric(ifelse(is.na(C["b2"]), 0, C["b2"]))#
	extras$x2 <- as.numeric(ifelse(is.na(C["b3"]), 0, C["b3"]))#
	extras$y2 <- as.numeric(ifelse(is.na(C["b5"]), 0, C["b5"]))#
	extras$xy <- as.numeric(ifelse(is.na(C["b4"]), 0, C["b4"]))#
	extras$w <- as.numeric(ifelse(is.na(C["b6"]), 0, C["b6"]))#
	extras$wx <- as.numeric(ifelse(is.na(C["b7"]), 0, C["b7"]))#
	extras$wy <- as.numeric(ifelse(is.na(C["b8"]), 0, C["b8"]))#
	# cubic parameters#
	extras$x3 <- as.numeric(ifelse(is.na(C["b9"]), 0, C["b9"]))#
	extras$xy2 <- as.numeric(ifelse(is.na(C["b10"]), 0, C["b10"]))#
	extras$x2y <- as.numeric(ifelse(is.na(C["b11"]), 0, C["b11"]))#
	extras$y3 <- as.numeric(ifelse(is.na(C["b12"]), 0, C["b12"]))#
#
	if (is.null(extras$xlim)) {#
		extras$xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
		# expand range by 20% at each end#
		extras$xlim[1] <- extras$xlim[1]*ifelse(extras$xlim[1]<0, 1.1, 0.9)#
		extras$xlim[2] <- extras$xlim[2]*ifelse(extras$xlim[2]<0, 0.9, 1.1)#
		extras$xlim[1] <- extras$ylim[1] <- min(extras$xlim[1], extras$ylim[1])#
	}#
	if (is.null(extras$ylim)) {#
		extras$ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
		extras$ylim[1] <- extras$ylim[1]*ifelse(extras$ylim[1]<0, 1.1, 0.9)#
		extras$ylim[2] <- extras$ylim[2]*ifelse(extras$ylim[2]<0, 0.9, 1.1)#
		extras$xlim[2] <- extras$ylim[2] <- max(extras$xlim[2], extras$ylim[2])#
	}#
	if (is.null(extras$xlab)) extras$xlab <- fit$IV1#
	if (is.null(extras$ylab)) extras$ylab <- fit$IV2#
	if (is.null(extras$zlab)) extras$zlab <- fit$DV#
	if (is.null(extras$points)) {#
		extras$points <- list(show=TRUE, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE)#
	}#
	extras$points$data <- fit$data[, c(fit$IV1, fit$IV2, fit$DV, colnames(fit$data)[which(!colnames(fit$data) %in% c(fit$IV1, fit$IV2, fit$DV))])]#
	extras$fit <- fit#
	do.call(plotRSA, as.list(extras))#
}#
#plot(r1, type="3d", points=list(show=TRUE, cex=2))#
#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, points=list(data=data.frame(x=-1:3, y=-1:3, z=0), show=TRUE))#
#
#plot(r1)#
#plot(r1, points=list(show=TRUE))#
#plotRSA(x=.05, x2=.1, xy=.20, type="3", gridsize=21)#
#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="3d", points=list(show=TRUE), rotation=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, type="3d")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, legend=FALSE, type="3d")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, legend=FALSE, type="c")#
#
#RSA.ST(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102)#
## Minimal example#
#x <- y <- z <- c(1,2,3)#
#df <- data.frame(x, y, z)#
#wireframe(z ~ x*y, df,  scales = list(arrows = FALSE, col = "black", font = 1, tck = c(1, 1, 1), distance =c(1, 1, 1)))#
##
##
#xyplot(z ~ x, df,  scales = list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck), par.settings=list(axis.components=list(left=list(pad1=2))))
plotRSA(surface="smooth", zlim=c(-1.5, 1.5), xlim=c(-3, 3), ylim=c(-3, 3), lambda=6, points=list(show=TRUE, data=dat1[, c("status_m", "status_w", "ras_m")]))
plot(r1, zlim=c(-1.5, 1.5), xlim=c(-3, 3), ylim=c(-3, 3))
compare(r1, plot=TRUE)
plot(r1, model="SRSD")
options(error=recover)
plot(r1, model="SRSD")
ls()
args
ls()
extras
extras$xlim
extras$ylim
options(error=NULL)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/RSA/package/R')
' @title Plots a response surface of a polynomial equation of second degree#
#'#
#' @description#
#' Plots an RSA object, or a response surface with specified parameters#
#'#
#' @details#
#' Each plot type has its distinctive advantages. The two-dimensional contour plot gives a clear view of the position of the principal axes and the stationary point. The 3d plot gives a three dimensional impression of the surface, allows overplotting of the original data points (in case an RSA object is provided), and allows the interactive adjustment of regression weights in the \code{\link{demoRSA}} function. The interactive plot allows rotating and exploring a three-dimensional surface with the mouse (nice for demonstration purposes).#
#' If you want to export publication-ready plots, it is recommended to export it with following commands:#
#' \code{p1 <- plot(r1, bw=TRUE)#
#' trellis.device(device="cairo_pdf", filename="RSA_plot.pdf")#
#' print(p1)#
#' dev.off()}#
#'#
#' @aliases plotRSA#
#'#
#' @export#
#' @param x Either an RSA object (returned by the \code{RSA} function), or the coefficient for the X predictor#
#' @param y Y coefficient#
#' @param x2 X^2 coefficient#
#' @param y2 Y^2 coefficient#
#' @param xy XY interaction coefficient#
#' @param w W coefficient (for (un)constrained absolute difference model)#
#' @param wx WX coefficient (for (un)constrained absolute difference model)#
#' @param wy WY coefficient (for (un)constrained absolute difference model)#
#' @param y3 Y^3 coefficient#
#' @param x3 X^3 coefficient#
#' @param xy2 XY^2 coefficient#
#' @param x2y X^2Y coefficient#
#' @param b0 Intercept#
#' @param xlim Limits of the x axis#
#' @param ylim Limits of the y axis#
#' @param zlim Limits of the z axis#
#' @param xlab Label for x axis#
#' @param ylab Label for y axis#
#' @param zlab Label for z axis#
#' @param surface Method for the calculation of the surface z values. "predict" takes the predicted values from the model, "smooth" uses a thin plate smoother (function \code{Tps} from the \code{fields} package) of the raw data#
#' @param lambda lambda parameter for the smoother. Default (NULL) means that it is estimated by the smoother function. Small lambdas around 1 lead to rugged surfaces, big lambdas to very smooth surfaces.#
#' @param rotation Rotation of the 3d surface plot (when type == "3d")#
#' @param label.rotation Rotation of the axis labls (when type == "3d")#
#' @param gridsize Number of grid nodes in each dimension#
#' @param bw Print surface in black and white instead of colors?#
#' @param legend Print color legend for z values?#
#' @param cex Font size factor for axes labels#
#' @param type \code{3d} for 3d surface plot, \code{contour} for 2d contour plot, "interactive" for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient#
#' @param points A list of parameters which define the appearance of the raw scatter points: #
#'	\itemize{#
#'		\item{data: Data frame which contains the coordinates of the raw data points. FIrst column = x, second = y, third = z. This data frame is automatically generated when the plot is based on a fitted RSA-object}#
#'		\item{show = TRUE: Should the original data points be overplotted?}#
#' 		\item{value="raw": Plot the original z value, "predicted": plot the predicted z value}#
#'		\item{jitter = 0: Amount of jitter for the raw data points. For z values, a value of 0.005 is reasonable}#
#'		\item{cex = .5: multiplication factor for point size}#
#' 		\item{out.mark = FALSE: If set to TRUE, outliers according to Bollen & Jackman (1980) are printed as red X symbols. This option works regardless of whether the RSA function has set out.rm to TRUE or FALSE: #
#'			\itemize{#
#'				\item{If out.rm == TRUE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is removed from the model and *not plotted* in plotRSA.}#
#'				\item{If out.rm == TRUE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is removed from the model but plotted and marked in plotRSA.}#
#'				\item{If out.rm == FALSE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is not removed from the model and plotted as a normal point in plotRSA (but not marked as outlier).}#
#'				\item{If out.rm == FALSE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is not removed from the model, but plotted and marked in plotRSA.}#
#'				\item{Example syntax: \code{plotRSA(r1, points=list(show=TRUE, out.mark=TRUE))}}#
#'		}}#
#'	}#
#
#' @param model If x is an RSA object: from which model should the response surface be computed?#
#' @param demo Do not change that parameter (internal use only)#
#' @param fit Do not change that parameter (internal use only)#
#' @param param Should the surface parameters a1 to a4 be shown on the plot? In case of a 3d plot a1 to a4 are printed on the upper left side; in case of a contour plot the principal axes are plotted.#
#' @param axes A vector of strings specifying the axes that should be plotted. Can be any combination of c("LOC", "LOIC", "PA1", "PA2"). LOC = line of congruence, LOIC = line of incongruence, PA1 = first principal axis, PA2 = second principal axis#
#' @param project Should the LOC, LOIC, etc. (as defined in parameter \code{axes}) be also plotted as a projection on the bottom of the cube?#
#' @param maxlines Should the maximum lines be plotted? (red: maximum X for a given Y, blue: maximum Y for a given X). Works only in type="3d"#
#' @param link Link function to transform the z axes. Implemented are "identity" (no transformation; default), "probit", and "logit"#
#' @param border Should a thicker border around the surface be plotted? Sometimes this border leaves the surrounding box, which does not look good. In this case the border can be suppressed by setting \code{border=FALSE}.#
#' @param contour A list defining the appearance of contour lines (aka. height lines). show=TRUE: Should the contour lines be plotted on the 3d wireframe plot? (Parameter only relevant for \code{type="3d"}). color = "grey40": Color of the contour lines. highlight = c(): A vector of heights which should be highlighted (i.e., printed in bold). Be careful: the highlighted line is not necessarily exactly at the specified height; instead the nearest height line is selected.#
#' @param hull Plot a bag plot on the surface (This is a bivariate extension of the boxplot. 50% of points are in the inner bag, 50% in the outer region). See Rousseeuw, Ruts, & Tukey (1999).#
#' @param SP.CI Plot the CI of the stationary point (only relevant for \code{type="contour"})#
#' @param distance A vector of three values defining the distance of labels to the axes#
#' @param tck A vector of three values defining the position of labels to the axes (see ?wireframe)#
#' @param pal A palette for shading#
#' @param pal.range Should the color range be scaled to the box (\code{pal.range = "box"}, default), or to the min and max of the surface (\code{pal.range = "surface"})? If set to "box", different surface plots can be compared along their color, as long as the zlim is the same for both.#
#' @param pad Pad controls the margin around the figure (positive numbers: larger margin, negative numbers: smaller margin)#
#'#' @param ... Additional parameters passed to the plotting function (e.g., sub="Title"). A useful title might be the R squared of the plotted model: sub = as.expression(bquote(R^2==.(round(getPar(x, "r2", model="full"), 3))))#
#'#
#' @references#
#' Rousseeuw, P. J., Ruts, I., & Tukey, J. W. (1999). The Bagplot: A Bivariate Boxplot. The American Statistician, 53(4), 382-387. doi:10.1080/00031305.1999.10474494#
#' @seealso \code{\link{demoRSA}}, \code{\link{RSA}}#
#'#
#' @examples#
#' # Plot response surfaces from known parameters#
#' # example of Edwards (2002), Figure 3#
#' # Default: 3d plot:#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628)#
#' # Contour plot:#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="c")#
#' # Interactive plot (try the mouse!):#
#' plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="i")#
#'#
#' # Plot response surface from an RSA object#
#' set.seed(0xBEEF)#
#' n <- 300#
#' err <- 2#
#' x <- rnorm(n, 0, 5)#
#' y <- rnorm(n, 0, 5)#
#' df <- data.frame(x, y)#
#' df <- within(df, {#
#' 	diff <- x-y#
#' 	absdiff <- abs(x-y)#
#' 	sqdiff <- (x-y)^2#
#' 	z.diff <- diff + rnorm(n, 0, err)#
#' 	z.abs <- absdiff + rnorm(n, 0, err)#
#' 	z.sq <- sqdiff + rnorm(n, 0, err)#
#' 	z.add <- diff + 0.4*x + rnorm(n, 0, err)#
#' 	z.complex <- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)#
#' })#
#' #
#' r1 <- RSA(z.sq~x*y, df, models=c("sqdiff", "full", "IA"))#
#' plot(r1)	# default: model = "full"#
#' plot(r1, model="sqdiff", points=list(show=TRUE, value="predicted"))#
#b0=0; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=0; wy=0;  zlim=NULL; xlim=c(-2, 2); ylim=c(-2, 2); rotation=list(x=-45, y=45, z=35); legend=TRUE; cex=1.2; type="3d"; points=TRUE; demo=FALSE; model="full"; #
#
#b0=-9; x=0; y=0; x2=0; y2=0; xy=0; w=0; wx=1; wy=-1;  zlim=NULL; xlim=c(-2, 2); ylim=c(-2, 2); rotation=list(x=-45, y=45, z=35); legend=TRUE; cex=1.2; type="3d"; points=TRUE; demo=FALSE; model="full"; fit=NULL; link="identity"; param=TRUE; gridsize=21;bw=FALSE; pal=NULL; axes=c("LOC", "LOIC", "PA1", "PA2"); distance=c(1, 1, 1); tck=c(1, 1, 1); xlab="X"; ylab="Y"; zlab="Z"; border=TRUE;#
#
## old rotation#
# rotation=list(x=-45, y=45, z=35), label.rotation=list(x=45, y=-25, z=94)#
# distance=c(1, 1, 1), tck=c(1, 1, 1)#
#
plotRSA <- function(x=0, y=0, x2=0, y2=0, xy=0, w=0, wx=0, wy=0, x3=0, xy2=0, x2y=0, y3=0, b0=0, type="3d", model="full", #
	xlim=NULL, ylim=NULL, zlim=NULL, xlab=NULL, ylab=NULL, zlab=NULL, #
	surface="predict", lambda=NULL, #
	rotation=list(x=-63, y=32, z=15), label.rotation=list(x=19, y=-40, z=92), #
	gridsize=21, bw=FALSE, legend=TRUE, param=TRUE, #
	axes=c("LOC", "LOIC", "PA1", "PA2"), project=FALSE, maxlines=FALSE,#
	cex=1.2,#
	points = list(data=NULL, show=NA, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE),#
	demo=FALSE, fit=NULL, link="identity", #
	tck=c(1.5, 1.5, 1.5), distance=c(1.3, 1.3, 1.4), border=TRUE, #
	contour = list(show=FALSE, color="grey40", highlight = c()),#
	hull=FALSE, SP.CI=FALSE, #
	pal=NULL, pal.range="box", #
	pad=0, ...) {#
	if (!identical(xlim, ylim)) {warning("Axes dimensions are not equal. The visual diagonal is *not* the line of numerical congruence! Consider choosing identical values for xlim and ylim.")}#
	# define the defaults#
	if (is.null(points$show)) points$show <- TRUE#
	if (is.na(points$show)) {#
		if (is.null(points$data)) {#
			points$show <- FALSE	#
		} else {#
			points$show <- TRUE#
		}#
	}#
	if (is.null(points$value)) points$value <- "raw"#
	if (is.null(points$color)) points$color <- "black"#
	if (is.null(points$jitter)) points$jitter <- 0#
	if (is.null(points$cex)) points$cex <- 0.5#
	if (is.null(points$out.mark)) points$out.mark <- FALSE#
	if (points$show==TRUE & is.null(points$data)) {#
		warning("You must provide a data frame with the coordinates of the raw data points (points = list(show = TRUE, data = ???)). Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (is.null(contour$show)) contour$show <- TRUE#
	if (is.null(contour$color)) contour$color <- "grey40"#
	if (is.null(contour$highlight)) contour$highlight <- c()#
	type <- match.arg(type, c("interactive", "3d", "contour"))#
	surface <- match.arg(surface, c("predict", "smooth"))#
	points[["value"]] <- match.arg(points[["value"]], c("raw", "predicted"))#
#
	if (demo == FALSE) {#
			if (is.null(xlab)) {#
				if (!is.null(points$data)) {#
					xlab <- colnames(points$data)[1]#
				} else {#
					xlab <- "X"#
				}#
			}#
			if (is.null(ylab)) {#
				if (!is.null(points$data)) {#
					ylab <- colnames(points$data)[2]#
				} else {#
					ylab <- "Y"#
				}#
			}#
			if (is.null(zlab)) {#
				if (!is.null(points$data)) {#
					zlab <- colnames(points$data)[3]#
				} else {#
					zlab <- "Z"#
				}#
			}#
			if (is.null(xlim)) {xlim <- c(-2.1, 2.1)}#
			if (is.null(ylim)) {ylim <- c(-2.1, 2.1)}#
	}#
	if (is.null(points$data) & surface == "smooth") {#
		warning("Smoothing only works if data points are provided (points=list(data=???))! Reverting to surface = 'predict'")#
		surface <- "predict"#
	}#
	C <- c(x, y, x2, y2, xy, w, wx, wy,x3, xy2, x2y, y3)#
	if (!model %in% c("absunc", "absdiff")) {#
		if (!is.null(fit) & model != "cubic" & model != "null") {#
			SP <- RSA.ST(fit, model=model)#
		} else {#
			SP <- RSA.ST(x=x, y=y, xy=xy, x2=x2, y2=y2)#
		}#
		SP.text <- paste0("a", 1:4, ": ", f2(SP$SP$estimate, 2), sig2star(SP$SP$p.value), collapse="    ")#
	} else {#
		SP <- NULL#
		param <- FALSE#
		SP.text <- ""#
	}#
	# build data set#
	grid <- gridsize#
	new <- data.frame(x = rep(seq(xlim[1], xlim[2], length.out=grid), grid), y = rep(seq(ylim[1], ylim[2], length.out=grid), each=grid))#
	new2 <- add.variables(z~x+y, new)#
	# calculate z values#
	if (surface == "predict") {#
		new2$z <- b0 + colSums(C*t(new2[, c(1:5, 9:11, 15:18)]))#
	}#
	if (surface == "smooth") {#
		library(fields)#
		tpsfit <- Tps(points$data[, 1:2], points$data[, 3], scale.type="unscaled", lambda=lambda)#
		new2$z <- predict(tpsfit, new[, c("x", "y")])#
		param <- FALSE#
		axes <- ""#
	}#
	# impose link functions#
	logit <- function (x) {log(x/(1-x))}#
	invlogit <- function (x) {1/(1+exp(-x))}#
	link <- match.arg(link, c("identity", "logit", "probit"))#
	if (link == "probit") {#
		z.trans <- 1.7 * new2$z#
		new2$z <- invlogit(z.trans)#
	}#
	if (link == "logit") {#
		new2$z <- invlogit(new2$z)#
	}#
#
	# determine zlim#
	if (!is.null(points$data) & demo==FALSE & is.null(zlim)) {#
		zlim <- c(min(min(new2$z, na.rm=TRUE), min(points$data[, 3], na.rm=TRUE)), max(max(new2$z, na.rm=TRUE), max(points$data[, 3], na.rm=TRUE)))#
	} else {#
		if (is.null(zlim)) zlim <- c(min(new2$z), max(new2$z))#
	}#
	zlim.final <- zlim#
	## Plots#
	if (bw == FALSE) {#
		# RdYlGn palette#
		if (is.null(pal)) {#
			pal <- c("#A50026","#D73027","#F46D43","#FDAE61","#FEE08B","#FFFFBF","#D9EF8B","#A6D96A","#66BD63","#1A9850","#006837")#
		}#
		gridCol <- ifelse(contour$show == TRUE, "grey60", "grey30")#
	} else {#
		if (is.null(pal)) {#
			pal <- colorRampPalette(c("#FFFFFF", "#AAAAAA", "#030303"), bias=2)(11)#
		}#
		gridCol <- ifelse(contour$show == TRUE, "grey30", "grey30")#
	}#
	if (length(pal) < 2) {legend <- FALSE}#
	# ---------------------------------------------------------------------#
	# Calculate positions of raw points#
#
	if (points$out.mark == TRUE & is.null(fit)) {#
		warning("Outliers can only be marked if an RSA-object is provided. Points are not plotted.")#
		points$show <- FALSE#
	}#
	if (points$show == TRUE) {#
		if (points$out.mark == FALSE) {#
			data.used <- points$data#
		}#
		if (points$out.mark == TRUE & !is.null(fit)) {#
			data.used <- fit$data.original#
		}#
		if (points$value == "raw") {#
			zpoints <- as.vector(data.used[, 3])#
		} else if (points$value == "predicted") {#
			N <- colnames(data.used)#
			data.used2 <- add.variables(formula(paste0(N[3], " ~ ", N[1], "*", N[2])), data.used)#
			# calculate predicted values#
			zpoints <- b0 + colSums(C*t(data.used2[, c(#
				N[1],#
				N[2],#
				paste0(N[1], "2"),#
				paste0(N[2], "2"),#
				paste0(N[1], "_", N[2]),#
				"W",#
				paste0("W_", N[1]),#
				paste0("W_", N[2]),#
				paste0(N[1], "3"),#
				paste0(N[1], "_", N[2], "2"),#
				paste0(N[1], "2", "_", N[2]),#
				paste0(N[2], "3")#
			)]))#
			zpoints <- as.vector(zpoints)#
		}#
#
		xpoints <- as.vector(data.used[, 1])#
		ypoints <- as.vector(data.used[, 2])#
	}#
	# ---------------------------------------------------------------------#
	#  calculate bag plot: bag = outer, loop = inner#
	if (hull==TRUE) {#
		library(aplpack)#
		BAG <- compute.bagplot(xpoints, ypoints)#
		# close the polygon#
		h1 <- rbind(BAG$hull.bag, BAG$hull.bag[1, ])#
		h2 <- rbind(BAG$hull.loop, BAG$hull.loop[1, ])#
#
		# approx: interpolate the points of the bag (in order to get a more smooth fitting line on the z-axis)#
		minDist <- min(diff(xlim)/gridsize, diff(ylim)/gridsize)/2#
#
		h1 <- interpolatePolyon(h1[, 1], h1[, 2], minDist=minDist)	#
		h2 <- interpolatePolyon(h2[, 1], h2[, 2], minDist=minDist)	#
		# calculate predicted values#
		bagpoints <- add.variables(z~x+y, data.frame(x=h1$x, y=h1$y))#
		bagpoints$z <- b0 + colSums(C*t(bagpoints[, c(1:5, 9:11, 15:18)]))#
		bag <- data.frame(X  = bagpoints$x, Y  = bagpoints$y, Z = bagpoints$z)#
		looppoints <- add.variables(z~x+y, data.frame(x=h2$x, y=h2$y))#
		looppoints$z <- b0 + colSums(C*t(looppoints[, c(1:5, 9:11, 15:18)]))#
		loop <- data.frame(X  = looppoints$x, Y  = looppoints$y, Z = looppoints$z)			#
	}#
	## ======================================================================#
	## Interactive plot#
	## ======================================================================#
	if (type == "interactive") {#
		library(rgl)#
		P <- list(x=seq(xlim[1], xlim[2], length.out=grid), y=seq(ylim[1], ylim[2], length.out=grid))#
		DV2 <- matrix(new2$z, nrow=grid, ncol=grid, byrow=FALSE)#
		R <- range(DV2)#
		col2 <- as.character(cut(1:(R[2] - R[1] + 1), breaks=length(pal), labels=pal))#
		open3d()#
		rgl.viewpoint(-30, -90)#
		rgl.light(theta = 0, phi = 90, viewpoint.rel = TRUE, ambient = "#FF0000", diffuse = "#FFFFFF", specular = "#FFFFFF")#
		persp3d(P$x, P$y, DV2, xlab = xlab, ylab = ylab, zlab = zlab, color=col2[DV2 - R[1] + 1])#
#
		if (contour$show == TRUE) {#
		    contours <- contourLines(P, z=DV2)#
		     for (i in 1:length(contours)) {#
				 with(contours[[i]], lines3d(x, y, level, col=contour$color))#
			 }#
		 }#
		if (points$show == TRUE) {#
			if (points$out.mark == FALSE) {#
				points3d(data.frame(xpoints, ypoints, zpoints), col=points$color)#
			}#
			if (points$out.mark == TRUE & !is.null(fit)) {#
				colvec <- rep(points$color, nrow(fit$data.original))#
				colvec[fit$outliers] <- "red"#
				points3d(fit$data.original[, c(fit$IV1, fit$IV2, fit$DV)], col=colvec)#
				text3d(fit$data.original[fit$outliers, c(fit$IV1, fit$IV2, fit$DV)], col="red", texts="X")#
			} else {#
				warning("Please provide an RSA-object to mark outliers.")#
			}#
		}#
		p1 <- NULL	# no plot object is returned	#
	}	#
	## ======================================================================#
	## Wireframe plot#
	## ======================================================================#
	if (type == "3d") {#
			mypanel2 <- function(x, y, z, xlim, ylim, zlim, xlim.scaled, ylim.scaled, zlim.scaled, axes, x.points=NULL, y.points=NULL, z.points=NULL, SPs="", ...) {#
			   # rescale absolute x, y, and z values so that they fit into the box#
			   RESCALE <- function(n) {#
				  X2 <- xlim.scaled[1] + diff(xlim.scaled) * (n$X - xlim[1]) / diff(xlim)#
	              Y2 <- ylim.scaled[1] + diff(ylim.scaled) * (n$Y - ylim[1]) / diff(ylim)#
	              Z2 <- zlim.scaled[1] + diff(zlim.scaled) * (n$Z - zlim[1]) / diff(zlim)#
				  df <- data.frame(X=X2, Y=Y2, Z=Z2)#
				  df <- df[df$X >= min(xlim.scaled) & df$X <= max(xlim.scaled) & df$Y >= min(ylim.scaled) & df$Y <= max(ylim.scaled) &  df$Z >= min(zlim.scaled) & df$Z <= max(zlim.scaled), ]#
				  return(df)#
			   }#
			# ---------------------------------------------------------------------#
			# 1. Projection on bottom of cube#
			  if (project==TRUE) {#
				  for (a in axes) {#
					  #print(paste("Plotting projection of", names(a)))#
					  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1, Z=zlim.final[1] + .01))#
		              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
				  } #
			  }#
			   # ---------------------------------------------------------------------#
			   # 2. Borders, back part#
					if (border==TRUE) {#
						  # Make boundary of grid a bit thicker#
						  box1 <- new2[new2$y == max(new2$y), ]#
						  box2 <- new2[new2$y == min(new2$y), ]#
						  box3 <- new2[new2$x == max(new2$x), ]#
						  box4 <- new2[new2$x == min(new2$x), ]#
						  box <- rbind(data.frame(box1, side=1), data.frame(box2, side=2), data.frame(box3, side=3), data.frame(box4, side=4))#
			              x.box <- xlim.scaled[1] + diff(xlim.scaled) * (box$x - xlim[1]) / diff(xlim)#
			              y.box <- ylim.scaled[1] + diff(ylim.scaled) * (box$y - ylim[1]) / diff(ylim)#
			              z.box <- zlim.scaled[1] + diff(zlim.scaled) * (box$z - zlim[1]) / diff(zlim)#
						  # plot the back lines of the border#
			              panel.3dscatter(x = x.box[box$side==1], y = y.box[box$side==1], z = z.box[box$side==1], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
						  panel.3dscatter(x = x.box[box$side==3], y = y.box[box$side==3], z = z.box[box$side==3], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=4, ...)#
					  }#
					  # ---------------------------------------------------------------------#
					  # 3. the surface#
						  panel.3dwire(x = x, y = y, z = z, xlim = xlim, ylim = ylim, zlim = zlim,#
		                           xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
								   col=gridCol,  lwd=0.3, ...)#
					# ---------------------------------------------------------------------#
					# 4. plot of LOC and LOIC, and other axes#
						  for (a in axes) {#
							  a0 <- RESCALE(getIntersect2(p0=a$p0, p1=a$p1))#
				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=a$col, lty=a$lty, lwd=2, ...)#
						  }   #
  					# ---------------------------------------------------------------------#
  					# 4b. plot of maximum lines#
					if (maxlines == TRUE) {#
						# maximum X for a given Y#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[1]/C[5]), p1=-((2*C[3])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="red", lty="dashed", lwd=2, ...)#
  							  a0 <- RESCALE(getIntersect2(p0=-(C[2]/(2*C[4])), p1=-((C[5])/(2*C[4]))))#
							  #a0 <- RESCALE(getIntersect2(p0=-(C[2]/C[5]), p1=-((2*C[4])/C[5])))#
  				              panel.3dscatter(x = a0$X, y = a0$Y, z = a0$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
  				                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
  											  type="l", col.line="blue", lty="dashed", lwd=2, ...)#
					}#
					# ---------------------------------------------------------------------#
					# 5. Borders, front part	  #
					   if (border==TRUE) {#
 						  # plot the front boundary lines#
 			              panel.3dscatter(x = x.box[box$side==2], y = y.box[box$side==2], z = z.box[box$side==2], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
						  panel.3dscatter(x = x.box[box$side==4], y = y.box[box$side==4], z = z.box[box$side==4], xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line=gridCol, lwd=3, ...)#
					   }#
						  if (param == TRUE) {#
							  grid.text(SPs, .02, .95, just="left")#
						  }  #
						# ---------------------------------------------------------------------#
						# 6a: The bag plot, if requested#
						if (hull==TRUE) {	#
							# bag (= inner bag)#
							if (any(bag$X < xlim[1] | bag$X > xlim[2] | bag$Y < ylim[1] | bag$Y > ylim[2])) {#
								warning("The bag is partly outside the plotting region. Bag is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  bag.rescale <- RESCALE(bag)#
		  		              panel.3dscatter(x = bag.rescale$X, y = bag.rescale$Y, z = bag.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="grey30", lty="dashed", lwd=2, ...)#
							}#
							# loop (= outer bag)#
							if (any(loop$X < xlim[1] | loop$X > xlim[2] | loop$Y < ylim[1] | loop$Y > ylim[2])) {#
								warning("The loop is partly outside the plotting region. Loop is not displayed, please adjust xlim and ylim to include the full range of raw data.")#
							} else {#
		  					  loop.rescale <- RESCALE(loop)#
		  		              panel.3dscatter(x = loop.rescale$X, y = loop.rescale$Y, z = loop.rescale$Z, xlim = xlim, ylim = ylim, zlim = zlim, xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled, type="l", col.line="black", lty="dashed", lwd=2, ...)#
							}#
						}	  	#
						# ---------------------------------------------------------------------#
						# 6b. Raw data points scatter plot	  #
					  		if (points$show == TRUE) {#
	  			              x2 <- xlim.scaled[1] + diff(xlim.scaled) * (x.points - xlim[1]) / diff(xlim)#
							  if (points$jitter > 0) x2 <- x2 + rnorm(length(x2), 0, points$jitter)#
	  			              y2 <- ylim.scaled[1] + diff(ylim.scaled) * (y.points - ylim[1]) / diff(ylim)#
							  if (points$jitter > 0) y2 <- y2 + rnorm(length(y2), 0, points$jitter)#
							  z2 <- zlim.scaled[1] + diff(zlim.scaled) * (z.points - zlim[1]) / diff(zlim)#
	  			              panel.3dscatter(x = x2, y = y2, z = z2, xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=20, col=points$color, cex=points$cex, ...)#
							  # plot outliers#
							  if (points$out.mark==TRUE) {#
	  			              	panel.3dscatter(x = x2[fit$outliers], y = y2[fit$outliers], z = z2[fit$outliers], xlim = xlim, ylim = ylim, zlim = zlim,#
	  			                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
	  										  pch=4, col="red", cex=points$cex, ...)#
							  }#
					  		}	#
					# ---------------------------------------------------------------------#
					# 7. plot contour lines:#
						if (contour$show == TRUE) {#
							cs <- ggplot(new2, aes_string(x="x", y="y", fill="z", z="z")) + stat_contour(bins=ifelse(length(pal)>1, length(pal)+1, 8))#
							cLines <- ggplot_build(cs)#
							C0 <- cLines$data[[1]][, c("x", "y", "level", "group")]#
							colnames(C0) <- c("X", "Y", "Z", "group")#
							for (cL in C0$group) {#
							  C1 <- RESCALE(C0[C0$group==cL, c("X", "Y", "Z")])#
				             panel.3dscatter(x = C1$X, y = C1$Y, z = C1$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
				                             xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
											  type="l", col.line=contour$color, lty="solid", lwd=1, ...)#
							}#
							# highlight specific contour lines?#
							if (length(contour$highlight) > 0) {#
								C2 <- C0[C0$Z %in% f0(unique(C0$Z), contour$highlight), ]#
								for (cL in C2$group) {#
								  C3 <- RESCALE(C2[C2$group==cL, c("X", "Y", "Z")])#
					              panel.3dscatter(x = C3$X, y = C3$Y, z = C3$Z, xlim = xlim, ylim = ylim, zlim = zlim,#
					                              xlim.scaled = xlim.scaled, ylim.scaled = ylim.scaled, zlim.scaled = zlim.scaled,#
												  type="l", col.line=contour$color, lty="solid", lwd=2, ...)#
								}#
							}#
						}#
				}#
				# local function: compute the surface line, defined by a line on the X-Y plane (p0 = intercept, p1=slope)#
				getIntersect2 <- function(p0, p1, Z=NULL) {#
					X <- seq(min(xlim), max(xlim), length.out=grid*2)#
					Y <- p0 + p1*X#
					n <- data.frame(X, Y)#
					n2 <- add.variables(z~X+Y, n)#
					n2$Z <- b0 + colSums(c(x, y, x2, y2, xy)*t(n2[, c(1:5)]))#
					if (!is.null(Z)) n2$Z <- Z#
					return(n2[, c("X", "Y", "Z")])#
				}#
				axesList <- list()#
				if ("LOC" %in% axes) {axesList[["LOC"]]  <- list(p0=0, p1=1, lty="solid", col="grey")}#
				if ("LOIC" %in% axes) {axesList[["LOIC"]] <- list(p0=0, p1=-1, lty="dotted", col="grey")}#
				if ("PA1" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA1")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA1"]] <- list(p0=SP2$p10, p1=SP2$p11, lty="solid", col="black")#
						} else {#
							axesList[["PA1"]] <- list(p0=SP$p10, p1=SP$p11, lty="solid", col="black")#
						}					#
				}#
				if ("PA2" %in% axes) {#
					if (x2 == y2) {#
						# print("Adjusting x2 to print PA2")#
						SP2 <- RSA.ST(x=x, y=y, xy=xy, x2=x2 + .001, y2=y2)#
						axesList[["PA2"]] <- list(p0=SP2$p20, p1=SP2$p21, lty="dotted", col="black")#
					} else {#
						axesList[["PA2"]] <- list(p0=SP$p20, p1=SP$p21, lty="dotted", col="black")	#
					}#
				}			#
				# Define color range: Relative to surface min/max, or relative to box (zlim)?#
				if (pal.range == "box") {#
					at <- seq(zlim[1], zlim[2], length.out=length(pal)-1)#
				} else if (pal.range == "surface") {#
					at <- seq(min(new2$z), max(new2$z), length.out=length(pal)-1)#
				}#
			if (points$show == FALSE) {#
				p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation, #
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2, ...)#
				#p1#
			} else {#
				p1 <- wireframe(z ~ x*y, new2,  drape=TRUE, #
					scales 	= list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck, distance=distance), #
					xlab	= list(cex=cex, label=xlab, rot=label.rotation[["x"]]), #
					ylab	= list(cex=cex, label=ylab, rot=label.rotation[["y"]]), #
					zlab	= list(cex=cex, label=zlab, rot=label.rotation[["z"]]), zlim=zlim, #
					screen	= rotation,#
					at		= at, col.regions=pal, colorkey=legend, #
					par.settings = list(#
						axis.line = list(col = "transparent"), #
						layout.heights = list(top.padding=pad, bottom.padding=pad), #
						layout.widths=list(left.padding=pad, right.padding=pad)), #
					axes	= axesList, #
					SPs		= SP.text, #
					panel.3d.wireframe = mypanel2,#
					x.points=xpoints, y.points=ypoints, z.points=zpoints, ...)#
			}#
	}  # of type == "3d"#
	## ======================================================================#
	## Contour plot#
	## ======================================================================#
	if (type == "contour") {#
		if (!all(C == 0)) {#
			# Define color range: Relative to surface min/max, or relative to box (zlim)?#
			if (pal.range == "box") {#
				limits <- c(zlim[1], zlim[2])#
			} else if (pal.range == "surface") {#
				limits <- c(min(new2$z), max(new2$z))#
			}#
			p1 <- ggplot(new2, aes_string(x="x", y="y", z="z")) + geom_tile(aes_string(fill="z")) + scale_fill_gradientn(zlab, colours=pal, limits=limits) + theme_bw() + theme(aspect.ratio=1) + xlab(xlab) + ylab(ylab)#
			if (legend==FALSE) {#
				p1 <- p1 + guides(fill=FALSE)#
			}#
			p1 <- p1 + stat_contour(bins=40, alpha=.4)#
			# highlight specific contour lines?#
			if (length(contour$highlight) > 0) {#
				cLines <- ggplot_build(p1)#
				C0 <- cLines$data[[2]][, c("x", "y", "level", "group")]#
#
				# Find closest values in contours#
				C1 <- C0[C0$level %in% f0(unique(C0$level), contour$highlight), ]#
				p1 <- p1 + geom_path(data=C1, aes_string(x="x", y="y", group="group", z="level"), size=1.1)#
			}#
			# (in)congruence lines#
			if ("LOC" %in% axes) {#
				p1 <- p1 + geom_abline(aes(xintercept=0, slope=1), color="grey")#
			}#
			if ("LOIC" %in% axes) {#
				p1 <- p1 + geom_abline(aes(xintercept=0, slope=-1), linetype="dotted", color="grey50")#
			}#
			if (("PA1" %in% axes) & !any(is.na(SP[c("p10", "p11")]))) {#
				p1 <- p1 + geom_abline(data=data.frame(SP[c("p10", "p11")]), aes_string(intercept="p10", slope="p11"))#
			}#
			if (("PA2" %in% axes) & !any(is.na(SP[c("p20", "p21")]))) {#
				p1 <- p1+ geom_abline(data=data.frame(SP[c("p20", "p21")]), aes_string(intercept="p20", slope="p21"), linetype="dotted")#
			}#
			if (param==TRUE & !any(is.na(SP[c("X0", "Y0")])) & !model %in% c("RR", "sqdiff", "SSD", "SRSD", "SRR", "SRRR")) {#
				p1 <- p1 + annotate("point", x=SP$X0, y=SP$Y0, z=max(new2$z))#
			}#
			if (points$show == TRUE) {#
				if (points$out.mark==FALSE) {#
					p1 <- p1 + annotate("point", x=xpoints, y=ypoints, color=points$color, size=3*points$cex)#
				}#
				if (points$out.mark==TRUE) {#
					colvec <- rep(points$color, nrow(fit$data.original))#
					colvec[fit$outliers] <- "red"#
					shapevec <- rep(19, nrow(fit$data.original))#
					shapevec[fit$outliers] <- 4#
					p1 <- p1 + annotate("point", x=fit$data.original[, fit$IV1], y=fit$data.original[, fit$IV2], color=colvec, size=3*points$cex, shape=shapevec)#
				}#
			}#
			if (hull==TRUE & !is.null(points$data)) {#
				p1 <- p1 + annotate("path", x=bag$X, y=bag$Y, linetype="dashed", color="grey10")#
				p1 <- p1 + annotate("path", x=loop$X, y=loop$Y, linetype="dotted", color="grey10")#
			}#
			# plot CI of SP#
			if (param==TRUE & SP.CI==TRUE & !is.null(fit)) {#
				PAR <- getPar(fit, "coef", model=model)#
				p1 <- p1 + annotate("errorbar", x=SP$X0, y=SP$Y0, ymin=PAR[PAR$label=="Y0", "ci.lower"], ymax=PAR[PAR$label=="Y0", "ci.upper"], z=max(new2$z), width=.3)#
				p1 <- p1 + annotate("errorbarh", x=SP$X0, y=SP$Y0, xmin=PAR[PAR$label=="X0", "ci.lower"], xmax=PAR[PAR$label=="X0", "ci.upper"], z=max(new2$z), height=.3)#
			}#
		}#
	}#
	return(p1)#
}#
#' @S3method plot RSA#
#
# Purpose: Extract the model parameters, xlim, xlab, etc. from the fitted object and give it to the plotRSA function#
plot.RSA <- function(x, ...) {#
	fit <- x#
	extras <- match.call(expand.dots = FALSE)$...#
	if (is.null(extras)) extras <- list()#
	if (is.null(extras$model)) extras$model <- "full"#
	C <- coef(fit$models[[extras$model]])#
	if (fit$models[[extras$model]]@Options$estimator != "DWLS") {#
		extras$b0 <- as.numeric(ifelse(is.na(C[paste0(fit$DV, "~1")]), 0, C[paste0(fit$DV, "~1")]))#
	} else {			#
		# the threshold is the negative of the intercept ...#
		extras$b0 <- -as.numeric(ifelse(is.na(C[paste0(fit$DV, "|t1")]), 0, C[paste0(fit$DV, "|t1")]))#
	}#
	extras$x <- as.numeric(ifelse(is.na(C["b1"]), 0, C["b1"]))#
	extras$y <- as.numeric(ifelse(is.na(C["b2"]), 0, C["b2"]))#
	extras$x2 <- as.numeric(ifelse(is.na(C["b3"]), 0, C["b3"]))#
	extras$y2 <- as.numeric(ifelse(is.na(C["b5"]), 0, C["b5"]))#
	extras$xy <- as.numeric(ifelse(is.na(C["b4"]), 0, C["b4"]))#
	extras$w <- as.numeric(ifelse(is.na(C["b6"]), 0, C["b6"]))#
	extras$wx <- as.numeric(ifelse(is.na(C["b7"]), 0, C["b7"]))#
	extras$wy <- as.numeric(ifelse(is.na(C["b8"]), 0, C["b8"]))#
	# cubic parameters#
	extras$x3 <- as.numeric(ifelse(is.na(C["b9"]), 0, C["b9"]))#
	extras$xy2 <- as.numeric(ifelse(is.na(C["b10"]), 0, C["b10"]))#
	extras$x2y <- as.numeric(ifelse(is.na(C["b11"]), 0, C["b11"]))#
	extras$y3 <- as.numeric(ifelse(is.na(C["b12"]), 0, C["b12"]))#
#
	adjust <- FALSE#
	if (is.null(extras$xlim)) {#
		extras$xlim <- c(min(fit$data[, fit$IV1], na.rm=TRUE), max(fit$data[, fit$IV1], na.rm=TRUE))#
		# expand range by 20% at each end#
		extras$xlim[1] <- extras$xlim[1]*ifelse(extras$xlim[1]<0, 1.1, 0.9)#
		extras$xlim[2] <- extras$xlim[2]*ifelse(extras$xlim[2]<0, 0.9, 1.1)#
		adjust <- TRUE#
	}#
	if (is.null(extras$ylim)) {#
		extras$ylim <- c(min(fit$data[, fit$IV2], na.rm=TRUE), max(fit$data[, fit$IV2], na.rm=TRUE))#
		extras$ylim[1] <- extras$ylim[1]*ifelse(extras$ylim[1]<0, 1.1, 0.9)#
		extras$ylim[2] <- extras$ylim[2]*ifelse(extras$ylim[2]<0, 0.9, 1.1)#
		adjust <- TRUE#
	}#
	if (adjust == TRUE) {#
		extras$xlim[1] <- extras$ylim[1] <- min(extras$xlim[1], extras$ylim[1])#
		extras$xlim[2] <- extras$ylim[2] <- max(extras$xlim[2], extras$ylim[2])#
	}#
	if (is.null(extras$xlab)) extras$xlab <- fit$IV1#
	if (is.null(extras$ylab)) extras$ylab <- fit$IV2#
	if (is.null(extras$zlab)) extras$zlab <- fit$DV#
	if (is.null(extras$points)) {#
		extras$points <- list(show=TRUE, value="raw", jitter=0, color="black", cex=.5, out.mark=FALSE)#
	}#
	extras$points$data <- fit$data[, c(fit$IV1, fit$IV2, fit$DV, colnames(fit$data)[which(!colnames(fit$data) %in% c(fit$IV1, fit$IV2, fit$DV))])]#
	extras$fit <- fit#
	do.call(plotRSA, as.list(extras))#
}#
#plot(r1, type="3d", points=list(show=TRUE, cex=2))#
#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, points=list(data=data.frame(x=-1:3, y=-1:3, z=0), show=TRUE))#
#
#plot(r1)#
#plot(r1, points=list(show=TRUE))#
#plotRSA(x=.05, x2=.1, xy=.20, type="3", gridsize=21)#
#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167)#
#demoRSA(x=.625, y=.519, x2=-.196, xy=.285, y2=-.167, type="c")#
##
#plotRSA(fit=r1, type="3d", points=list(show=TRUE), rotation=list(x=-58, y=50, z=26))#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, type="c")#
#plotRSA(x=.05, x2=.1, xy=.20, rotation=list(x=-50, y=58, z=36), legend=FALSE, type="3d")#
##
## exampe of Edwards, 2002, Figure 3#
#p1 <- plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, legend=FALSE, type="3d")#
#plotRSA(b0=5.628, x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, legend=FALSE, type="c")#
#
#RSA.ST(x=.314, y=-.118, x2=-.145, xy=.299, y2=-.102)#
## Minimal example#
#x <- y <- z <- c(1,2,3)#
#df <- data.frame(x, y, z)#
#wireframe(z ~ x*y, df,  scales = list(arrows = FALSE, col = "black", font = 1, tck = c(1, 1, 1), distance =c(1, 1, 1)))#
##
##
#xyplot(z ~ x, df,  scales = list(arrows = FALSE, cex=cex, col = "black", font = 1, tck=tck), par.settings=list(axis.components=list(left=list(pad1=2))))
plot(r1, model="SRSD")
plot(r1, model="SRSD", points=list(show=FALSE))
plot(r1, model="full", points=list(show=FALSE))
plot(r1, model="SSD", points=list(show=FALSE))
plot(r1, model="SRSD", points=list(show=FALSE))
plot(r1, model="IA", points=list(show=FALSE))
getPar(r1, model="SRSD")
plot(r1, model="SSD", points=list(show=FALSE))
plot(r1, model="SRSD")
plot(r1, model="SSD")
plotRSA(surface="smooth", zlim=c(-1.5, 1.5), xlim=c(-3, 3), ylim=c(-3, 3), lambda=6, points=list(show=TRUE, data=dat1[, c("status_m", "status_w", "ras_w")]))
r2 <- RSA(ras_w ~ status_m*status_w, dat1)#
plot(r2, model="additive")
r1
r2
compute squared and interaction terms#
dat2 <- RSA:::add.variables(ras_m ~ status_m*status_w, dat1)#
#
model <- "#
# polynomial regression for both outcomes#
ras_m ~ b1m*status_m + b2m*status_w + b3m*status_m2 + b4m*status_m_status_w + b5m*status_w2#
ras_w ~ b1w*status_m + b2w*status_w + b3w*status_m2 + b4w*status_m_status_w + b5w*status_w2#
#
# Residual correlation of DV#
ras_m ~~ ras_w#
#
## Defined parameters#
# Male surface#
a1m := b1m+b2m#
a2m := b3m+b4m+b5m#
a3m := b1m-b2m#
a4m := b3m-b4m+b5m#
x0m := (b2m*b4m - 2*b1m*b5m) / (4*b3m*b5m - b4m^2)#
y0m := (b1m*b4m - 2*b2m*b3m) / (4*b3m*b5m - b4m^2)#
l1m := (b3m + b5m + sqrt((b3m+b5m)^2 - 4*b3m*b5m + b4m^2))/2#
l2m := (b3m + b5m - sqrt((b3m+b5m)^2 - 4*b3m*b5m + b4m^2))/2#
#
# Female surface#
a1w := b1w+b2w#
a2w := b3w+b4w+b5w#
a3w := b1w-b2w#
a4w := b3w-b4w+b5w#
x0w := (b2w*b4w - 2*b1w*b5w) / (4*b3w*b5w - b4w^2)#
y0w := (b1w*b4w - 2*b2w*b3w) / (4*b3w*b5w - b4w^2)#
l1w := (b3w + b5w + sqrt((b3w+b5w)^2 - 4*b3w*b5w + b4w^2))/2#
l2w := (b3w + b5w - sqrt((b3w+b5w)^2 - 4*b3w*b5w + b4w^2))/2#
"#
#
fit1 <- sem(model, data=dat2, fixed.x=TRUE, meanstructure=TRUE)#
summary(fit1)
model.equal <- "#
# polynomial regression for both outcomes#
ras_m ~ b1m*status_m + b2m*status_w + b3m*status_m2 + b4m*status_m_status_w + b5m*status_w2#
ras_w ~ b1w*status_m + b2w*status_w + b3w*status_m2 + b4w*status_m_status_w + b5w*status_w2#
#
# Residual correlation of DV#
ras_m ~~ ras_w#
#
# constraints: set male and female equal#
b1m == b1w#
b2m == b2w#
b3m == b3w#
b4m == b4w#
b5m == b5w#
#
## Defined parameters#
# Joint surface#
a1 := b1m+b2m#
a2 := b3m+b4m+b5m#
a3 := b1m-b2m#
a4 := b3m-b4m+b5m#
x0 := (b2m*b4m - 2*b1m*b5m) / (4*b3m*b5m - b4m^2)#
y0 := (b1m*b4m - 2*b2m*b3m) / (4*b3m*b5m - b4m^2)#
l1 := (b3m + b5m + sqrt((b3m+b5m)^2 - 4*b3m*b5m + b4m^2))/2#
l2 := (b3m + b5m - sqrt((b3m+b5m)^2 - 4*b3m*b5m + b4m^2))/2#
"#
#
fit2 <- sem(model.equal, data=dat2, fixed.x=TRUE, meanstructure=TRUE)#
summary(fit2)
anova(fit1, fit2)
library(memisc)
?memisc
library(memisc)#
dat0 <- as.data.frame(spss.portable.file("raw/Equity_Dyad_Felix.por"))
setwd('/Users/Felix/Documents/LMU/Research/1 - Konkret in Arbeit/Yorck - RSA/munge')
library(memisc)#
dat0 <- as.data.frame(spss.portable.file("raw/Equity_Dyad_Felix.por"))
